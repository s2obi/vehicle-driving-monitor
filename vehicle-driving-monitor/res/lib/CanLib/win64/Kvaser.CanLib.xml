<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Kvaser.CanLib</name>
    </assembly>
    <members>
        <member name="F:Kvaser.CanLib.CanLibDLL.MAX_STRING_SIZE">
            <summary>Maximum size of strings.</summary>
        </member>
        <member name="T:Kvaser.CanLib.CanLibDLL.canBusStatistics">
            <summary>This struct is returned by <see cref="M:Kvaser.CanLib.CanLibDLL.canGetBusStatistics(System.Int32,System.IntPtr,System.UInt64)"/></summary>
        </member>
        <member name="F:Kvaser.CanLib.CanLibDLL.canBusStatistics.stdData">
            <summary>Number of received standard (11-bit identifiers) data frames.</summary>
        </member>
        <member name="F:Kvaser.CanLib.CanLibDLL.canBusStatistics.stdRemote">
            <summary> Number of received standard (11-bit identifiers) remote frames.</summary>
        </member>
        <member name="F:Kvaser.CanLib.CanLibDLL.canBusStatistics.extData">
            <summary>Number of received extended (29-bit identifiers) data frames.</summary>
        </member>
        <member name="F:Kvaser.CanLib.CanLibDLL.canBusStatistics.extRemote">
            <summary>Number of received extended (29-bit identifiers) remote frames. </summary>
        </member>
        <member name="F:Kvaser.CanLib.CanLibDLL.canBusStatistics.errFrame">
            <summary>Number of error frames</summary>
        </member>
        <member name="F:Kvaser.CanLib.CanLibDLL.canBusStatistics.busLoad">
            <summary>The bus load, expressed as an integer in the interval 0 - 10000
            representing 0.00% - 100.00% bus load.</summary>
        </member>
        <member name="F:Kvaser.CanLib.CanLibDLL.canBusStatistics.overruns">
            <summary>The number of overruns detected by the hardware, firmware or driver.</summary>
        </member>
        <member name="T:Kvaser.CanLib.CanLibDLL.canUserIoPortData">
            <summary>This struct is returned in <see cref="F:Kvaser.CanLib.Canlib.canIOCTL_SET_USER_IOPORT"/> and <see cref="F:Kvaser.CanLib.Canlib.canIOCTL_GET_USER_IOPORT"/>.</summary>C
        </member>
        <member name="F:Kvaser.CanLib.CanLibDLL.canUserIoPortData.portNo">
            <summary>Port number.</summary>
        </member>
        <member name="F:Kvaser.CanLib.CanLibDLL.canUserIoPortData.portValue">
            <summary>Port value.</summary>
        </member>
        <member name="T:Kvaser.CanLib.Canlib">
            <summary>
                The canlib DLL is a library for interacting with the CAN bus.
            </summary>
        </member>
        <member name="M:Kvaser.CanLib.Canlib.canAccept(System.Int32,System.Int32,System.Int32)">
             <summary>
             This routine sets the message acceptance filters on a CAN channel.
            
             On some boards the acceptance filtering is done by the CAN hardware; on other boards(typically those
             with an embedded CPU,) the acceptance filtering is done by software. <see cref="M:Kvaser.CanLib.Canlib.canAccept(System.Int32,System.Int32,System.Int32)"/> behaves in the same way
             for all boards, however.
            
             <see cref="M:Kvaser.CanLib.Canlib.canSetAcceptanceFilter(System.Int32,System.Int32,System.Int32,System.Int32)"/> and <see cref="M:Kvaser.CanLib.Canlib.canAccept(System.Int32,System.Int32,System.Int32)"/> both serve the same purpose but the former can set the code
             and mask in just one call.
            
             If you want to remove a filter, call <see cref="M:Kvaser.CanLib.Canlib.canAccept(System.Int32,System.Int32,System.Int32)"/> with the mask set to 0.
             Note
             You can set the extended code and mask only on CAN boards that support extended identifiers.
             Acceptance filters for 11-bit and 29-bit (ext) are independent, meaning 11-bit filters
             will not affect 29-bit can frames and vice versa.
             Not all CAN boards support different masks for standard and extended CAN identifiers.
             </summary>
             <param name="handle">An open handle to a CAN circuit.</param>
             <param name="envelope">The mask or code to set.</param>
             <param name="flag">Any of <see cref="F:Kvaser.CanLib.Canlib.canFILTER_SET_CODE_STD"/>, <see cref="F:Kvaser.CanLib.Canlib.canFILTER_SET_MASK_STD"/>, <see cref="F:Kvaser.CanLib.Canlib.canFILTER_SET_CODE_EXT"/> or <see cref="F:Kvaser.CanLib.Canlib.canFILTER_SET_MASK_EXT"/></param>
             <returns><see cref="F:Kvaser.CanLib.Canlib.canStatus.canOK"/> if success else canStatus.canERR_XXX.</returns>
        </member>
        <member name="M:Kvaser.CanLib.Canlib.canBusOff(System.Int32)">
            <summary>
            Takes the specified handle off-bus. If no other handle is active on the same channel, the channel
            will also be taken off-bus
            </summary>
            <param name="handle">An open handle to a CAN channel.</param>
            <returns><see cref="F:Kvaser.CanLib.Canlib.canStatus.canOK"/> if success else canStatus.canERR_XXX.</returns>
        </member>
        <member name="M:Kvaser.CanLib.Canlib.canBusOn(System.Int32)">
             <summary>
             Takes the specified channel on-bus.
            
             If you are using multiple handles to the same physical channel, for example if you are writing
             a threaded application, you must call <see cref="M:Kvaser.CanLib.Canlib.canBusOn(System.Int32)"/> once for each handle. The same applies to canBusOff()
             - the physical channel will not go off bus until the last handle to the channel goes off bus.
             </summary>
             <param name="handle">An open handle to a CAN channel.</param>
             <returns><see cref="F:Kvaser.CanLib.Canlib.canStatus.canOK"/> if success else canStatus.canERR_XXX.</returns>
        </member>
        <member name="M:Kvaser.CanLib.Canlib.canClose(System.Int32)">
            <summary>
             Closes the channel associated with the handle. If no other threads
            are using the CAN circuit, it is taken off bus. The handle can not be
            used for further references to the channel.
            </summary>
            <param name="handle">An open handle to a CAN channel.</param>
            <returns><see cref="F:Kvaser.CanLib.Canlib.canStatus.canOK"/> if success else canStatus.canERR_XXX.</returns>
        </member>
        <member name="M:Kvaser.CanLib.Canlib.canFlushReceiveQueue(System.Int32)">
             <summary>This function removes all received messages from the handle's receive queue. Other handles open to
             the same channel are not affected by this operation. That is, only the messages belonging to the handle
             you are passing to canFlushReceiveQueue are discarded.
            
             Note: This call has the same effect as calling <see cref="M:Kvaser.CanLib.Canlib.canIoCtl(System.Int32,System.Int32,System.Int32@)"/> with a function code of <see cref="F:Kvaser.CanLib.Canlib.canIOCTL_FLUSH_RX_BUFFER"/>.
             </summary>
             <param name="hnd">A handle to an open circuit.</param>
             <returns><see cref="F:Kvaser.CanLib.Canlib.canStatus.canOK"/> if success else canStatus.canERR_XXX.</returns>
        </member>
        <member name="M:Kvaser.CanLib.Canlib.canFlushTransmitQueue(System.Int32)">
             <summary>
             This function removes all messages pending transmission from the transmit queue of the circuit.
            
             Note: If there are other handles open to the same circuit, they are also flushed.This call has the same effect as
             calling <see cref="M:Kvaser.CanLib.Canlib.canIoCtl(System.Int32,System.Int32,System.Int32@)"/> with a function code of <see cref="F:Kvaser.CanLib.Canlib.canIOCTL_FLUSH_TX_BUFFER"/>.
             </summary>
             <param name="hnd">A handle to an open circuit.</param>
             <returns><see cref="F:Kvaser.CanLib.Canlib.canStatus.canOK"/> if success else canStatus.canERR_XXX.</returns>
        </member>
        <member name="M:Kvaser.CanLib.Canlib.canGetBusOutputControl(System.Int32,System.Int32@)">
            <summary>
            This function retrieves the current CAN controller driver type. This corresponds loosely to the bus output control
            register in the CAN controller, hence the name of this function. CANlib does not allow for direct manipulation of
            the bus output control register; instead, symbolic constants are used to select the desired driver type.
            <para>&#160;</para>
            Note: Don't confuse the CAN controller driver type with the bus driver type. The CAN controller is not connected
            directly to the CAN bus; instead, it is connected to a bus transceiver circuit which interfaces directly to the bus.
            The "CAN controller driver type" we are talking about here refers to the mode which the CAN controller uses to drive
            the bus transceiver circuit.Silent Mode is not supported by all CAN controllers.
            </summary>
            <param name="handle">An open handle to a CAN circuit.</param>
            <param name="drivertype">A reference to an int which receives the current driver type. The driver type can be
             either <see cref="F:Kvaser.CanLib.Canlib.canDRIVER_NORMAL"/> or <see cref="F:Kvaser.CanLib.Canlib.canDRIVER_SILENT"/>.</param>
            <returns><see cref="F:Kvaser.CanLib.Canlib.canStatus.canOK"/> if success else canStatus.canERR_XXX.</returns>
        </member>
        <member name="M:Kvaser.CanLib.Canlib.canGetBusParams(System.Int32,System.Int64@,System.Int32@,System.Int32@,System.Int32@,System.Int32@)">
             <summary>
             This function retrieves the current nominal bus parameters for the specified channel.
            
             The anatomy of a CAN bit is discussed in detail at Kvaser's web site at www.kvaser.com.
             </summary>
             <param name="handle">An open handle to a CAN controller.</param>
             <param name="freq">Bit rate (bits per second).</param>
             <param name="tseg1">Time segment 1, that is, the number of quanta from (but not including) the Sync Segment to the sampling point.</param>
             <param name="tseg2">Time segment 2, that is, the number of quanta from the sampling point to the end of the bit.</param>
             <param name="sjw">The Synchronization Jump Width.</param>
             <param name="noSamp">The number of sampling points; can be 1 or 3.</param>
             <returns><see cref="F:Kvaser.CanLib.Canlib.canStatus.canOK"/> if success else canStatus.canERR_XXX.</returns>
        </member>
        <member name="M:Kvaser.CanLib.Canlib.canGetBusParamsFd(System.Int32,System.Int64@,System.Int32@,System.Int32@,System.Int32@)">
            <summary>
            This function retrieves the current data bus parameters for the specified CAN FD channel.
            </summary>
            <param name="handle">An open handle to a CAN FD controller.</param>
            <param name="freq">Bit rate (bits per second).</param>
            <param name="tseg1">Time segment 1, that is, the number of quanta from (but not including) the Sync Segment to the sampling point.</param>
            <param name="tseg2">Time segment 2, that is, the number of quanta from the sampling point to the end of the bit.</param>
            <param name="sjw">The Synchronization Jump Width.</param>
            <returns><see cref="F:Kvaser.CanLib.Canlib.canStatus.canOK"/> if success else canStatus.canERR_XXX.</returns>
        </member>
        <member name="M:Kvaser.CanLib.Canlib.canGetBusStatistics(System.Int32,Kvaser.CanLib.Canlib.canBusStatistics@)">
            <summary>
            The <see cref="M:Kvaser.CanLib.Canlib.canGetBusStatistics(System.Int32,Kvaser.CanLib.Canlib.canBusStatistics@)"/> function retrieves the latest bus statistics figures reported by the driver. You request the bus
            statistics from the driver by calling the <see cref="M:Kvaser.CanLib.Canlib.canRequestBusStatistics(System.Int32)"/> function.
            </summary>
            <param name="hnd">An open handle to a CAN channel.</param>
            <param name="stat">A reference to a canBusStatistics struct that will receive the bus statistics figures.</param>
            <returns><see cref="F:Kvaser.CanLib.Canlib.canStatus.canOK"/> if success else canStatus.canERR_XXX.</returns>
        </member>
        <member name="M:Kvaser.CanLib.Canlib.canGetDriverMode(System.Int32,System.Int32@,System.Int32@)">
             <summary>
             This function retrieves the current CAN bus driver mode. This is typically a mode like sleep, wakeup, standby, fast mode,
             etc. The different modes are almost always hardware dependent and requires special DRVcan cables. As an example, the DRVcan
             S implements J2411 compliant single-wire CAN and supports four line modes, namely Normal, Sleep, Fast and Wakeup.
            
             Standard ISO 11898 CAN do not support any of these bus driver modes.
             <para>&#160;</para>
             Note: The bus driver mode is typically used to control things like one- or two-wire mode, sleep mode, and so on. It requires
             special support in the CAN driver circuit.
            
             Not implemented in Linux
             </summary>
             <param name="hnd">An open handle to a CAN circuit.</param>
             <param name="lineMode">A reference to an int which receives the current line mode (canTRANSCEIVER_LINEMODE_xxx).</param>
             <param name="resNet">A reference to an int which receives the current resnet mode. This value is usually <see cref="F:Kvaser.CanLib.Canlib.canTRANSCEIVER_RESNET_NA"/>
             except for special DRVcan cables.</param>
             <returns><see cref="F:Kvaser.CanLib.Canlib.canStatus.canOK"/> if success else canStatus.canERR_XXX.</returns>
        </member>
        <member name="M:Kvaser.CanLib.Canlib.canGetErrorText(Kvaser.CanLib.Canlib.canStatus,System.String@)">
            <summary>
            This function translates an error code (canERR_xxx) to a human-readable, English text.
            </summary>
            <param name="err">The error code.</param>
            <param name="buf_str">A reference to a string containing the error text</param>
            <returns><see cref="F:Kvaser.CanLib.Canlib.canStatus.canOK"/> if success else canStatus.canERR_XXX.</returns>
        </member>
        <member name="M:Kvaser.CanLib.Canlib.canGetChannelData(System.Int32,System.Int32,System.Object@)">
            <summary>
            This function can be used to retrieve certain pieces of information about a channel.
            You must pass a channel number and not a channel handle.
            </summary>
            <param name="channel">The number of the channel you are interested in. Channel
                                  numbers are integers in the interval beginning at 0
                                  (zero) and ending at the value returned by
                                  <see cref="M:Kvaser.CanLib.Canlib.canGetNumberOfChannels(System.Int32@)" />, minus 1.</param>
            <param name="item">This parameter specifies what data to obtain for the
                               specified channel. The value is one of the constants canCHANNELDATA_xxx.</param>
            <param name="buffer">The Object with received data.</param>
            <returns><see cref="F:Kvaser.CanLib.Canlib.canStatus.canOK"/> if success else canStatus.canERR_XXX.</returns>
        </member>
        <member name="M:Kvaser.CanLib.Canlib.canGetHandleData(System.Int32,System.Int32,System.Object@)">
            <summary>
            This function can be used to retrieve certain pieces of information about an open handle to a CANlib channel.
            </summary>
            <param name="hnd">An open handle to a CAN channel.</param>
            <param name="item">This parameter specifies what data to obtain for the specified handle. The value is one of the constants canCHANNELDATA_xxx</param>
            <param name="buffer">return value as a object</param>
            <returns></returns>
        </member>
        <member name="M:Kvaser.CanLib.Canlib.canGetNumberOfChannels(System.Int32@)">
            <summary> This function returns the number of available CAN channels in the computer. The virtual channels
            are included in this number.</summary>
            <param name="channelCount">A reference to an Int32 which will receive the current number of channels.</param>
            <returns><see cref="F:Kvaser.CanLib.Canlib.canStatus.canOK"/> if success else canStatus.canERR_XXX.</returns>
        </member>
        <member name="M:Kvaser.CanLib.Canlib.canEnumHardwareEx(System.Int32@)">
            <summary> This function recreates the channel table and returns the number of available CAN channels in the computer.
            The virtual channels are included in this number.</summary>
            <param name="channelCount">A reference to an Int32 which will receive the current number of channels.</param>
            <returns><see cref="F:Kvaser.CanLib.Canlib.canStatus.canOK"/> if success else canStatus.canERR_XXX.</returns>
        </member>
        <member name="M:Kvaser.CanLib.Canlib.canGetVersion">
             <summary>This API call returns the version of the CANlib API DLL (canlib32.dll). The most significant byte is
             the major version number and the least significant byte is the minor version number.
             The actual version of the different driver files can be obtained by studying the version resources in each of the files.
            
             <para>&#160;</para>
             Note: The version number of the canlib32.dll file is not related to the product version of CANlib you are using. CANlib
             consists of several driver and DLL files. To obtain the product version, use <see cref="M:Kvaser.CanLib.Canlib.canGetVersionEx(System.Int32)"/>.
             </summary>
             <returns>Version number of canlib32.dll
             <para>&#160;</para>
             Note: Linux returns version number from libcanlib.so</returns>
        </member>
        <member name="M:Kvaser.CanLib.Canlib.canGetVersionEx(System.Int32)">
            <summary> This function returns various version numbers from the driver routines.</summary>
            <param name="itemCode">Specifies which version number to retrieve. See canVERSION_CANLIB32_xxx</param>
            <returns>The return value is the desired version number.</returns>
        </member>
        <member name="M:Kvaser.CanLib.Canlib.canInitializeLibrary">
            <summary> This function must be called before any other functions are used. It will initialize the driver.
            You may call <see cref="M:Kvaser.CanLib.Canlib.canInitializeLibrary"/> more than once. The actual initialization will take place only once.
            Any errors encountered during library initialization will be "silent" and an appropriate canERR_xxx error code
            will be returned later on when <see cref="M:Kvaser.CanLib.Canlib.canOpenChannel(System.Int32,System.Int32)"/> (or any other API call that requires initialization) is called.</summary>
        </member>
        <member name="M:Kvaser.CanLib.Canlib.canIoCtl(System.Int32,System.Int32,System.Int32@)">
            <summary>This function performs several different functions defined as CanIOCTL_xxx.
            The functions are handle-specific unless otherwise noted; this means that they affect only the handle you pass to canIoCtl(),
            whereas other open handles will remain unaffected. The contents of val after the call is dependent on the function code you specified.</summary>
            <param name="handle">A handle to an open circuit.</param>
            <param name="func">A canIOCTL_xxx function code .</param>
            <param name="val">Value to Get</param>
            <returns><see cref="F:Kvaser.CanLib.Canlib.canStatus.canOK"/> if success else canStatus.canERR_XXX.</returns>
        </member>
        <member name="M:Kvaser.CanLib.Canlib.canIoCtl(System.Int32,System.Int32,System.String@)">
            <summary>This function performs several different functions defined as CanIOCTL_xxx.
            The functions are handle-specific unless otherwise noted; this means that they affect only the handle you pass to canIoCtl(),
            whereas other open handles will remain unaffected. The contents of val after the call is dependent on the function code you specified.
            </summary>
            <param name="handle">A handle to an open circuit.</param>
            <param name="func">A canIOCTL_xxx function code .</param>
            <param name="str_buf">Return value as String</param>
            <returns><see cref="F:Kvaser.CanLib.Canlib.canStatus.canOK"/> if success else canStatus.canERR_XXX.</returns>
        </member>
        <member name="M:Kvaser.CanLib.Canlib.canIoCtl(System.Int32,System.Int32,System.Object@)">
            <summary>This function performs several different functions defined as CanIOCTL_xxx.
            The functions are handle-specific unless otherwise noted; this means that they affect only the handle you pass to canIoCtl(),
            whereas other open handles will remain unaffected. The contents of val after the call is dependent on the function code you specified.
            </summary>
            <param name="handle">A handle to an open circuit.</param>
            <param name="func">A canIOCTL_xxx function code .</param>
            <param name="obj_buf">Set/Get value as an Object</param>
            <returns><see cref="F:Kvaser.CanLib.Canlib.canStatus.canOK"/> if success else canStatus.canERR_XXX.</returns>
        </member>
        <member name="M:Kvaser.CanLib.Canlib.canObjBufAllocate(System.Int32,Kvaser.CanLib.Canlib.canObjBufType)">
            <summary>Allocates an object buffer associated with a handle to a CAN circuit.</summary>
            <param name="handle">An open handle to a CAN circuit.</param>
            <param name="type">The type of the buffer.</param>
            <returns>A buffer index (zero or positive) if success. canERR_xxx (negative) if failure</returns>
        </member>
        <member name="M:Kvaser.CanLib.Canlib.canObjBufDisable(System.Int32,System.Int32)">
            <summary>Disables the object buffer with the specified index.</summary>
            <param name="handle">An open handle to a CAN circuit. </param>
            <param name="idx">The index of the buffer.</param>
            <returns><see cref="F:Kvaser.CanLib.Canlib.canStatus.canOK"/> if success else canStatus.canERR_XXX.</returns>
        </member>
        <member name="M:Kvaser.CanLib.Canlib.canObjBufEnable(System.Int32,System.Int32)">
            <summary>Enables the object buffer with the specified index.</summary>
            <param name="handle">An open handle to a CAN circuit. </param>
            <param name="idx">The index of the object buffer to enable.</param>
            <returns><see cref="F:Kvaser.CanLib.Canlib.canStatus.canOK"/> if success else canStatus.canERR_XXX.</returns>
        </member>
        <member name="M:Kvaser.CanLib.Canlib.canObjBufFree(System.Int32,System.Int32)">
            <summary>Deallocates the object buffer with the specified index. The buffer can not be referenced after this operation.</summary>
            <param name="handle">An open handle to a CAN circuit. </param>
            <param name="idx">The object buffer to deallocate.</param>
            <returns><see cref="F:Kvaser.CanLib.Canlib.canStatus.canOK"/> if success else canStatus.canERR_XXX.</returns>
        </member>
        <member name="M:Kvaser.CanLib.Canlib.canObjBufFreeAll(System.Int32)">
            <summary>Deallocates all object buffers on the specified handle. The buffers cannot be referenced after this operation.</summary>
            <param name="handle">An open handle to a CAN circuit. </param>
            <returns><see cref="F:Kvaser.CanLib.Canlib.canStatus.canOK"/> if success else canStatus.canERR_XXX.</returns>
        </member>
        <member name="M:Kvaser.CanLib.Canlib.canObjBufSendBurst(System.Int32,System.Int32,System.Int32)">
             <summary>The canObjBufSendBurst function sends a burst of CAN messages. You have to set up an object buffer
             first with the message to send. The messages will be sent as fast as possible from the hardware.
            <para>&#160;</para>
            
             This function is intended for certain diagnostic applications.
             </summary>
             <param name="handle">An open handle to a CAN channel.</param>
             <param name="idx">The index of a CAN object buffer.</param>
             <param name="burstlen">The number of messages to send.</param>
             <returns><see cref="F:Kvaser.CanLib.Canlib.canStatus.canOK"/> if success else canStatus.canERR_XXX.</returns>
        </member>
        <member name="M:Kvaser.CanLib.Canlib.canObjBufSetFilter(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>Defines a message reception filter on the specified object buffer. Messages not matching
            the filter are discarded.
            Note: For an auto response buffer, set the code and mask that together define the identifier(s) that
            trigger(s) the automatic response.
            </summary>
            <param name="handle">An open handle to a CAN circuit.</param>
            <param name="idx">The index of the object buffer on which the filter is to be set.</param>
            <param name="code">The acceptance code in the filter.</param>
            <param name="mask">The acceptance mask in the filter.</param>
            <returns><see cref="F:Kvaser.CanLib.Canlib.canStatus.canOK"/> if success else canStatus.canERR_XXX.</returns>
        </member>
        <member name="M:Kvaser.CanLib.Canlib.canObjBufSetFlags(System.Int32,System.Int32,System.Int32)">
            <summary>Sets object buffer flags on a specified object buffer.</summary>
            <param name="handle">An open handle to a CAN circuit.</param>
            <param name="idx">The buffer on which the flags are to be set.</param>
            <param name="flags">Specifies a combination of zero or more of the canOBJBUF_AUTO_RESPONSE_xxx flag values.</param>
            <returns><see cref="F:Kvaser.CanLib.Canlib.canStatus.canOK"/> if success else canStatus.canERR_XXX.</returns>
        </member>
        <member name="M:Kvaser.CanLib.Canlib.canObjBufSetMsgCount(System.Int32,System.Int32,System.Int32)">
            <summary>The canObjBufSetMsgCount function sets the message count for an auto transmit object buffer.</summary>
            <param name="handle">An open handle to a CAN channel.</param>
            <param name="idx">The index of a CAN object buffer.</param>
            <param name="count">The message count.</param>
            <returns><see cref="F:Kvaser.CanLib.Canlib.canStatus.canOK"/> if success else canStatus.canERR_XXX.</returns>
        </member>
        <member name="M:Kvaser.CanLib.Canlib.canObjBufSetPeriod(System.Int32,System.Int32,System.Int32)">
            <summary>The canObjBufSetPeriod function sets the transmission period for an auto transmission object buffer.</summary>
            <param name="handle">An open handle to a CAN channel.</param>
            <param name="idx">The index of a CAN object buffer.</param>
            <param name="period">The transmission interval, in microseconds.</param>
            <returns><see cref="F:Kvaser.CanLib.Canlib.canStatus.canOK"/> if success else canStatus.canERR_XXX.</returns>
        </member>
        <member name="M:Kvaser.CanLib.Canlib.canObjBufWrite(System.Int32,System.Int32,System.Int32,System.Byte[],System.Int32,System.Int32)">
            <summary>Defines the contents of a specific object buffer.</summary>
            <param name="handle">An open handle to a CAN circuit.</param>
            <param name="idx">The index of the object buffer whose contents is to be defined.</param>
            <param name="id">The CAN identifier of the message.</param>
            <param name="msg">The contents of the message.</param>
            <param name="dlc">The length of the message in bytes.
            For Classic CAN dlc can be at most 8, unless <see cref="F:Kvaser.CanLib.Canlib.canOPEN_ACCEPT_LARGE_DLC"/> is used.
            For CAN FD dlc can be one of the following 0-8, 12, 16, 20, 24, 32, 48, 64.</param>
            <param name="flags">Message flags; a combination of the canMSG_xxx flags.</param>
            <returns><see cref="F:Kvaser.CanLib.Canlib.canStatus.canOK"/> if success else canStatus.canERR_XXX.</returns>
        </member>
        <member name="M:Kvaser.CanLib.Canlib.canOpenChannel(System.Int32,System.Int32)">
            <summary>
             Opens a CAN channel (circuit) and returns a handle which is used
             in subsequent calls to CANlib. You can open the same channel from multiple threads, but you must
             call <see cref="M:Kvaser.CanLib.Canlib.canOpenChannel(System.Int32,System.Int32)"/> once per thread.
            </summary>
            <param name="channel">The number of the channel. Channel numbering is hardware dependent.</param>
            <param name="flags">A combination of canOPEN_xxx flags</param>
            <returns>Returns a handle to the opened circuit, or canERR_xxx (negative) if the call failed.</returns>
        </member>
        <member name="M:Kvaser.CanLib.Canlib.canParamCommitChanges">
             <summary>
             This function writes the current set of named parameters to the Registry. Previous entries are erased.
            
             The named parameters are stored in the HKEY_LOCAL_MACHINE\SOFTWARE\KVASER AB\CANLIB32\PredefinedBitrates key in the Registry.
            
             Note
             You must have Administrator's rights to write to the Registry.
             </summary>
             <returns><see cref="F:Kvaser.CanLib.Canlib.canStatus.canOK"/> if success else canStatus.canERR_XXX.</returns>
        </member>
        <member name="M:Kvaser.CanLib.Canlib.canParamCreateNewEntry">
             <summary>
             This function creates a new entry in the table of named parameter settings.
            
             The named parameters are stored in the HKEY_LOCAL_MACHINE\SOFTWARE\KVASER AB\CANLIB32\PredefinedBitrates key in the Registry.
            
             Note
             You must have Administrator's rights to write to the Registry.
             </summary>
             <returns>The index of the created entry (zero or positive) if success else canStatus.canERR_XXX.</returns>
        </member>
        <member name="M:Kvaser.CanLib.Canlib.canParamDeleteEntry(System.Int32)">
             <summary>
             This function deletes the entry in the table of named parameter settings with the given index.
             The entries below (i.e. with higher indices) the deleted entry are moved up one step in the table.
            
             The named parameters are stored in the HKEY_LOCAL_MACHINE\SOFTWARE\KVASER AB\CANLIB32\PredefinedBitrates key in the Registry.
             </summary>
             <param name="index">The index of the entry to delete.</param>
             <returns><see cref="F:Kvaser.CanLib.Canlib.canStatus.canOK"/> if success else canStatus.canERR_XXX.</returns>
        </member>
        <member name="M:Kvaser.CanLib.Canlib.canParamFindByName(System.String)">
            <summary>
            This function returns the index of the parameter setting with the given name.
            </summary>
            <param name="str_name">The name of the setting.</param>
            <returns>The index of the setting (zero or positive) if success else canStatus.canERR_XXX.</returns>
        </member>
        <member name="M:Kvaser.CanLib.Canlib.canParamGetBusParams(System.Int32,System.Int32@,System.Int32@,System.Int32@,System.Int32@,System.Int32@)">
            <summary>
            This function retrieves the bus parameters associated with the entry with the given index in the table of named
            parameter settings.
            </summary>
            <param name="index">The index of the entry in the table of named parameter settings.</param>
            <param name="bitrate">Bit rate (bits per second).</param>
            <param name="tseg1">Time segment 1, that is, the number of quanta from (but not including) the
            Sync Segment to the sampling point.</param>
            <param name="tseg2">Time segment 2, that is, the number of quanta from the sampling point to
            the end of the bit.</param>
            <param name="sjw">The Synchronization Jump Width.</param>
            <param name="noSamp">The number of sampling points; can be 1 or 3.</param>
            <returns><see cref="F:Kvaser.CanLib.Canlib.canStatus.canOK"/> if success else canStatus.canERR_XXX.</returns>
        </member>
        <member name="M:Kvaser.CanLib.Canlib.canParamGetChannelNumber(System.Int32)">
            <summary>
            This function returns the channel number of the entry with the given index in the table of named parameter settings.
            </summary>
            <param name="index">The index of the entry in the table of named parameter settings.</param>
            <returns>The channel number of the entry in question (zero or positive) if success else canStatus.canERR_XXX.</returns>
        </member>
        <member name="M:Kvaser.CanLib.Canlib.canParamGetCount">
            <summary>
            This function returns the number of entries in the table of named channels.
            </summary>
            <returns>The number of channels (zero or positive) if success else canStatus.canERR_XXX.</returns>
        </member>
        <member name="M:Kvaser.CanLib.Canlib.canParamGetName(System.Int32,System.String@)">
             <summary>
             This function returns the name of a given entry in the list of named parameters.
            
             The named parameters are stored in the HKEY_LOCAL_MACHINE\SOFTWARE\KVASER AB\CANLIB32\PredefinedBitrates key in the Registry.
             </summary>
             <param name="index">The index of the entry in the named parameters list, whose name is to be returned.</param>
             <param name="str_buf">A reference to a string that is to receive the name.</param>
             <returns><see cref="F:Kvaser.CanLib.Canlib.canStatus.canOK"/> if success else canStatus.canERR_XXX.</returns>
        </member>
        <member name="M:Kvaser.CanLib.Canlib.canParamSetBusParams(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
             <summary>
             This function sets or changes the bus parameters for a given entry in the list of named parameters.
            
             Note: The bus parameters are not checked for validity.
             </summary>
             <param name="index">The index of the entry in the named parameter list whose parameters are to be set or changed.</param>
             <param name="bitrate">Bit rate (measured in bits per second); or one of the predefined constants canBITRATE_xxx.</param>
             <param name="tseg1">Time segment 1, that is, the number of quanta from (but not including) the
             Sync Segment to the sampling point.</param>
             <param name="tseg2">Time segment 2, that is, the number of quanta from the sampling point to
             the end of the bit.</param>
             <param name="sjw">The Synchronization Jump Width.</param>
             <param name="noSamp">The number of sampling points; can be 1 or 3.</param>
             <returns><see cref="F:Kvaser.CanLib.Canlib.canStatus.canOK"/> if success else canStatus.canERR_XXX.</returns>
        </member>
        <member name="M:Kvaser.CanLib.Canlib.canParamSetChannelNumber(System.Int32,System.Int32)">
            <summary>
            This function sets the channel number for a specified entry in the list of named parameters. Channels are numbered from 0 and up.
            </summary>
            <param name="index">The index of the entry in the named parameter list whose channel number is to be set.</param>
            <param name="channel">The channel number</param>
            <returns><see cref="F:Kvaser.CanLib.Canlib.canStatus.canOK"/> if success else canStatus.canERR_XXX.</returns>
        </member>
        <member name="M:Kvaser.CanLib.Canlib.canParamSetName(System.Int32,System.String)">
            <summary>
            This function sets or changes the name of a named parameter.
            </summary>
            <param name="index">The index of the named parameter whose name is to be changed or set.</param>
            <param name="str_buf">A string that contains the new name. If the string is longer than the
            maximum allowed name length, it is truncated.</param>
            <returns><see cref="F:Kvaser.CanLib.Canlib.canStatus.canOK"/> if success else canStatus.canERR_XXX.</returns>
        </member>
        <member name="M:Kvaser.CanLib.Canlib.canParamSwapEntries(System.Int32,System.Int32)">
             <summary>
             This function swaps two entries in the list of named parameters.
            
             The named parameters are stored in the HKEY_LOCAL_MACHINE\SOFTWARE\KVASER AB\CANLIB32\PredefinedBitrates key in the Registry.
             </summary>
             <param name="index1">The first of the two entries that are to be swapped in the named parameters list.</param>
             <param name="index2">The second of the two entries that are to be swapped in the named parameters list.</param>
             <returns><see cref="F:Kvaser.CanLib.Canlib.canStatus.canOK"/> if success else canStatus.canERR_XXX.</returns>
        </member>
        <member name="M:Kvaser.CanLib.Canlib.canProbeVersion(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
             <summary>
             This function checks whether a specific version of CANlib is installed on the system.
            
             The default behaviour of canProbeVersion is to accept the version specified by major and minor, and any later version, and
             all beta versions.
            
             You get the default behaviour by setting flags to 0. Use any combination of the canVERSION_xxx flags to modify the behaviour.
             Note: Different handles might have different driver versions installed.This should not normally be the case but it might happen
             anyway.You should check the version for each handle you open, e.g.directly after calling canOpenChannel().
             </summary>
             <param name="hnd">A handle to an open circuit.</param>
             <param name="major">The major version number of the version to test for.</param>
             <param name="minor">The minor version number of the version to test for.</param>
             <param name="oem_id">Reserved, must be zero.</param>
             <param name="flags">Any combination of the canVERSION_xxx flags, or 0.</param>
             <returns>TRUE if the specified version of CANlib is installed on the system.</returns>
        </member>
        <member name="M:Kvaser.CanLib.Canlib.CopyFrameData(System.Byte[],System.Byte[],System.Int32)">
            <summary>
            Helper method to avoid code duplication in CanReadXXX methods.
            </summary>
        </member>
        <member name="M:Kvaser.CanLib.Canlib.canRead(System.Int32,System.Int32@,System.Byte[],System.Int32@,System.Int32@,System.Int64@)">
             <summary>
             Reads a message from the receive buffer. If no message is available, the function returns immediately
             with return code <see cref="F:Kvaser.CanLib.Canlib.canStatus.canERR_NOMSG"/>.
            
             If you are using the same channel via multiple handles, note that the default behaviour is that the
             different handles will "hear" each other just as if each handle referred to a channel of its own. If
             you open, say, channel 0 from thread A and thread B and then send a message from thread A, it will be
             "received" by thread B. This behaviour can be changed using <see cref="F:Kvaser.CanLib.Canlib.canIOCTL_SET_LOCAL_TXECHO"/>.
             </summary>
             <param name="handle">A handle to an open circuit.</param>
             <param name="id">A reference to a buffer which receives the CAN identifier. This buffer will only get the
             identifier. To determine whether this identifier was standard (11-bit) or extended (29-bit), and/or
             whether it was remote or not, or if it was an error frame, examine the contents of the flag argument.</param>
             <param name="msg">A reference to the buffer which receives the message data. The output will be 8 or 64 byte
             depending on the type of message that was received (normal or CAN FD).</param>
             <param name="dlc">A reference to a buffer which will receive the message length.</param>
             <param name="flag">A reference to a buffer which receives the message flags, which is a combination of
             the canMSG_xxx (including canFDMSG_xxx if the CAN FD protocol is enabled) and canMSGERR_xxx values.</param>
             <param name="time">A reference to a buffer which receives the message time stamp.</param>
             <returns><see cref="F:Kvaser.CanLib.Canlib.canStatus.canOK"/> if a message was read. <see cref="F:Kvaser.CanLib.Canlib.canStatus.canERR_NOMSG"/> if there was no message available, canERR_xxx if failure</returns>
        </member>
        <member name="M:Kvaser.CanLib.Canlib.canReadErrorCounters(System.Int32,System.Int32@,System.Int32@,System.Int32@)">
             <summary>
             Reads the error counters of the CAN controller.
            
             <see cref="M:Kvaser.CanLib.Canlib.canReadErrorCounters(System.Int32,System.Int32@,System.Int32@,System.Int32@)"/> returns the latest known values of the error counters in the specified circuit.If the error counters change
             values precisely when <see cref="M:Kvaser.CanLib.Canlib.canReadErrorCounters(System.Int32,System.Int32@,System.Int32@,System.Int32@)"/> is called, it may not be reflected in the returned result.
            
             Use <see cref="M:Kvaser.CanLib.Canlib.canIoCtl(System.Int32,System.Int32,System.Int32@)"/> to clear the counters.
            
             Note: Not all CAN controllers provide access to the error counters; in this case, an educated guess is returned.
             </summary>
             <param name="handle">A handle to an open circuit.</param>
             <param name="txErr">A reference to an int which receives the transmit error counter.</param>
             <param name="rxErr">A reference to an int which receives the receive error counter.</param>
             <param name="ovErr">A reference to an int which receives the which receives the number of overrun errors.</param>
             <returns><see cref="F:Kvaser.CanLib.Canlib.canStatus.canOK"/> if success else canStatus.canERR_XXX.</returns>
        </member>
        <member name="M:Kvaser.CanLib.Canlib.canReadSpecific(System.Int32,System.Int32,System.Byte[],System.Int32@,System.Int32@,System.Int64@)">
             <summary>
             Reads a message with a specified identifier from the receive buffer. Any preceding message not matching
             the specified identifier will be kept in the receive buffer. If no message with the specified identifier
             is available, the function returns immediately with an error code.
            
             If you are using the same channel via multiple handles, note that the default behaviour is that the different
             handles will "hear" each other just as if each handle referred to a channel of its own. If you open, say,
             channel 0 from thread A and thread B and then send a message from thread A, it will be "received" by thread B.
             This behaviour can be changed using <see cref="F:Kvaser.CanLib.Canlib.canIOCTL_SET_LOCAL_TXECHO"/>.
            
             </summary>
             <param name="handle">A handle to an open circuit.</param>
             <param name="id">The desired CAN identifier.</param>
             <param name="msg">A reference to the buffer which receives the message data. The output will be 8 or 64 byte
             depending on the type of message that was received (normal or CAN FD).</param>
             <param name="dlc">A reference to a buffer which will receive the message length.</param>
             <param name="flag">A reference to a buffer which receives the message flags, which is a combination of
             the canMSG_xxx (including canFDMSG_xxx if the CAN FD protocol is enabled) and canMSGERR_xxx values.</param>
             <param name="time">A reference to a buffer which receives the message time stamp.</param>
             <returns><see cref="F:Kvaser.CanLib.Canlib.canStatus.canOK"/> if a message was read. <see cref="F:Kvaser.CanLib.Canlib.canStatus.canERR_NOMSG"/> if there was no message available, canERR_xxx if failure</returns>
        </member>
        <member name="M:Kvaser.CanLib.Canlib.canReadSpecificSkip(System.Int32,System.Int32,System.Byte[],System.Int32@,System.Int32@,System.Int64@)">
             <summary>
             Reads a message with a specified identifier from the receive buffer. Any preceding message not matching
             the specified identifier will be removed in the receive buffer. If no message with the specified identifier
             is available, the function returns immediately with an error code.
            
             If you are using the same channel via multiple handles, note that the default behaviour is that the different
             handles will "hear" each other just as if each handle referred to a channel of its own. If you open, say,
             channel 0 from thread A and thread B and then send a message from thread A, it will be "received" by thread B.
             This behaviour can be changed using <see cref="F:Kvaser.CanLib.Canlib.canIOCTL_SET_LOCAL_TXECHO"/>.
            
             </summary>
             <param name="hnd">A handle to an open circuit.</param>
             <param name="id">The desired CAN identifier.</param>
             <param name="msg">A reference to the buffer which receives the message data. The output will be 8 or 64 byte
             depending on the type of message that was received (normal or CAN FD).</param>
             <param name="dlc">A reference to a buffer which will receive the message length.</param>
             <param name="flag">A reference to a buffer which receives the message flags, which is a combination of
             the canMSG_xxx (including canFDMSG_xxx if the CAN FD protocol is enabled) and canMSGERR_xxx values.</param>
             <param name="time">A reference to a buffer which receives the message time stamp.</param>
             <returns><see cref="F:Kvaser.CanLib.Canlib.canStatus.canOK"/> if a message was read. <see cref="F:Kvaser.CanLib.Canlib.canStatus.canERR_NOMSG"/> if there was no message available, canERR_xxx if failure</returns>
        </member>
        <member name="M:Kvaser.CanLib.Canlib.canReadStatus(System.Int32,System.Int64@)">
            <summary>
            Returns the status for the specified circuit.
            flags receives a combination of the canSTAT_xxx flags.
            </summary>
            <param name="handle">A handle to an open circuit.</param>
            <param name="flags">a long which receives the status flags; this is a combination of any of the canSTAT_xxx.</param>
            <returns><see cref="F:Kvaser.CanLib.Canlib.canStatus.canOK"/> if success else canStatus.canERR_XXX.</returns>
        </member>
        <member name="M:Kvaser.CanLib.Canlib.canReadSync(System.Int32,System.Int64)">
             <summary>
             Waits until the receive buffer contains at least one message or a timeout occurs.
            
             If you are using the same channel via multiple handles, note that the default behaviour is that the different handles
             will "hear" each other just as if each handle referred to a channel of its own.If you open, say, channel 0 from thread
             A and thread B and then send a message from thread A, it will be "received" by thread B.This behaviour can be changed
             using <see cref="F:Kvaser.CanLib.Canlib.canIOCTL_SET_LOCAL_TXECHO"/>.
             </summary>
             <param name="handle">A handle to an open circuit.</param>
             <param name="timeout">The timeout in milliseconds. 0xFFFFFFFF gives an infinite timeout.</param>
             <returns><see cref="F:Kvaser.CanLib.Canlib.canStatus.canOK"/> (zero) if the queue contains the desired message.
             <see cref="F:Kvaser.CanLib.Canlib.canStatus.canERR_TIMEOUT"/> (negative) if a timeout occurs before a message arrived.
             canERR_xxx (negative) if the call fails.</returns>
        </member>
        <member name="M:Kvaser.CanLib.Canlib.canReadSyncSpecific(System.Int32,System.Int32,System.Int64)">
             <summary>
             Waits until the receive queue contains a message with the specified id, or a timeout occurs.
            
             If you are using the same channel via multiple handles, note that the default behaviour is that the
             different handles will "hear" each other just as if each handle referred to a channel of its own.
             If you open, say, channel 0 from thread A and thread B and then send a message from thread A, it will
             be "received" by thread B. This behaviour can be changed using <see cref="F:Kvaser.CanLib.Canlib.canIOCTL_SET_LOCAL_TXECHO"/>.
             </summary>
             <param name="handle">A handle to an open circuit.</param>
             <param name="id">The desired message identifier.</param>
             <param name="timeout">The timeout in milliseconds. 0xFFFFFFFF gives an infinite timeout.</param>
             <returns><see cref="F:Kvaser.CanLib.Canlib.canStatus.canOK"/> (zero) if the queue contains the desired message.
             <see cref="F:Kvaser.CanLib.Canlib.canStatus.canERR_TIMEOUT"/> (negative) if a timeout occurs before a message arrived.
             canERR_xxx (negative) if the call fails.</returns>
        </member>
        <member name="M:Kvaser.CanLib.Canlib.canRequestBusStatistics(System.Int32)">
             <summary>
             The canRequestBusStatistics function requests bus statistics from the hardware. The bus statistics figures can be retrieved later by a call
             to the canGetBusStatistics function.
            
             <para>&#160;</para>
             Note: The time between a call to <see cref="M:Kvaser.CanLib.Canlib.canRequestBusStatistics(System.Int32)"/> and the point in time where the bus statistics is actually available via a call
             to <see cref="M:Kvaser.CanLib.Canlib.canGetBusStatistics(System.Int32,Kvaser.CanLib.Canlib.canBusStatistics@)"/> is not defined. Typically, you would call <see cref="M:Kvaser.CanLib.Canlib.canRequestBusStatistics(System.Int32)"/> from your application periodically (for example,
             once per second) to request the data from the driver and then call <see cref="M:Kvaser.CanLib.Canlib.canGetBusStatistics(System.Int32,Kvaser.CanLib.Canlib.canBusStatistics@)"/> with the same rate to obtain the latest reported data.
             </summary>
             <param name="hnd">An open handle to a CAN channel.</param>
             <returns><see cref="F:Kvaser.CanLib.Canlib.canStatus.canOK"/> if success else canStatus.canERR_XXX.</returns>
        </member>
        <member name="M:Kvaser.CanLib.Canlib.canRequestChipStatus(System.Int32)">
             <summary>
             The <see cref="M:Kvaser.CanLib.Canlib.canRequestChipStatus(System.Int32)"/> function requests that the hardware report the chip status (bus on/error passive status etc.) to the driver.
              The chip status can later be retrieved using the <see cref="M:Kvaser.CanLib.Canlib.canReadStatus(System.Int32,System.Int64@)"/> function.
            <para>&#160;</para>
             Note: The <see cref="M:Kvaser.CanLib.Canlib.canRequestChipStatus(System.Int32)"/> function is asynchronous, that is, it completes before the answer is returned from the hardware.
             The time between a call to <see cref="M:Kvaser.CanLib.Canlib.canRequestChipStatus(System.Int32)"/> and the point in time where the chip status is actually available via a call
             to <see cref="M:Kvaser.CanLib.Canlib.canReadStatus(System.Int32,System.Int64@)"/> is not defined. <see cref="M:Kvaser.CanLib.Canlib.canReadStatus(System.Int32,System.Int64@)"/> always returns the latest data reported by the hardware.
             </summary>
             <param name="hnd">An open handle to a CAN channel.</param>
             <returns><see cref="F:Kvaser.CanLib.Canlib.canStatus.canOK"/> if success else canStatus.canERR_XXX.</returns>
        </member>
        <member name="M:Kvaser.CanLib.Canlib.canResetBus(System.Int32)">
             <summary>
             This function tries to reset a CAN bus controller by taking the channel off bus and then on bus again
             (if it was on bus before the call to <see cref="M:Kvaser.CanLib.Canlib.canResetBus(System.Int32)"/>).
            
             This function will affect the hardware (and cause a real reset of the CAN chip) only if handle is the only
             handle open on the channel. If there are other open handles, this operation will not affect the hardware.
             </summary>
             <param name="handle"></param>
             <returns><see cref="F:Kvaser.CanLib.Canlib.canStatus.canOK"/> if success else canStatus.canERR_XXX.</returns>
        </member>
        <member name="M:Kvaser.CanLib.Canlib.canReadWait(System.Int32,System.Int32@,System.Byte[],System.Int32@,System.Int32@,System.Int64@,System.Int64)">
             <summary>
             Reads a message from the receive buffer. If no message is available, the function waits until a message arrives or a timeout occurs.
            
             If you are using the same channel via multiple handles, note that the default behaviour is that the different handles will "hear" each
             other just as if each handle referred to a channel of its own. If you open, say, channel 0 from thread A and thread B and then send a
             message from thread A, it will be "received" by thread B. This behaviour can be changed using <see cref="F:Kvaser.CanLib.Canlib.canIOCTL_SET_LOCAL_TXECHO"/>.
             </summary>
             <param name="handle">A handle to an open circuit.</param>
             <param name="id">A reference to a buffer which receives the CAN identifier. This buffer will only get the
             identifier. To determine whether this identifier was standard (11-bit) or extended (29-bit), and/or
             whether it was remote or not, or if it was an error frame, examine the contents of the flag argument.</param>
             <param name="msg">A reference to the buffer which receives the message data. The output will be 8 or 64 byte
             depending on the type of message that was received (normal or CAN FD).</param>
             <param name="dlc">A reference to a buffer which will receive the message length.</param>
             <param name="flag">A reference to a buffer which receives the message flags, which is a combination of
             the canMSG_xxx (including canFDMSG_xxx if the CAN FD protocol is enabled) and canMSGERR_xxx values.</param>
             <param name="time">A reference to a buffer which receives the message time stamp.</param>
             <param name="timeout">If no message is immediately available, this parameter gives the number of milliseconds to wait for a message before
             returning. 0xFFFFFFFF gives an infinite timeout.</param>
             <returns><see cref="F:Kvaser.CanLib.Canlib.canStatus.canOK"/> if success,
                        <see cref = "F:Kvaser.CanLib.Canlib.canStatus.canERR_NOMSG"/> if there was no message available.
                        else canStatus.canERR_XXX if failure.</returns>
        </member>
        <member name="M:Kvaser.CanLib.Canlib.canSetAcceptanceFilter(System.Int32,System.Int32,System.Int32,System.Int32)">
             <summary>
             This routine sets the message acceptance filters on a CAN channel.
            
             Format of code and mask:
             A binary 1 in a mask means "the corresponding bit in the code isrelevant"
             A binary 0 in a mask means "the corresponding bit in the code is notrelevant"
             A relevant binary 1 in a code means "the corresponding bit in theidentifier must be 1"
             A relevant binary 1 in a code means "the corresponding bit in theidentifier must be 1"
            
             In other words, the message is accepted if ((code XOR id) AND mask) == 0.
            
             is_extended should be set to:
             0: if the code and mask shall apply to 11-bit CAN identifiers.
             1: if the code and mask shall apply to 29-bit CAN identifiers.
            
             If you want to remove a filter, call canSetAcceptanceFilter() with the mask set to 0.
            
             On some boards the acceptance filtering is done by the CAN hardware; on other boards(typically those with an embedded CPU,)
             the acceptance filtering is done by software. <see cref="M:Kvaser.CanLib.Canlib.canSetAcceptanceFilter(System.Int32,System.Int32,System.Int32,System.Int32)"/> behaves in the same way for all boards, however.
            
             <see cref="M:Kvaser.CanLib.Canlib.canSetAcceptanceFilter(System.Int32,System.Int32,System.Int32,System.Int32)"/> and <see cref="M:Kvaser.CanLib.Canlib.canAccept(System.Int32,System.Int32,System.Int32)"/> both serve the same purpose but the former can set the code and mask in just one call.
            
             Note: You can set the extended code and mask only on CAN boards that support extended identifiers.Not all CAN boards support
             different masks for standard and extended CAN identifiers.
            
             Not implemented in linux.
             </summary>
             <param name="hnd">An open handle to a CAN circuit.</param>
             <param name="code">The acceptance code to set.</param>
             <param name="mask">The acceptance mask to set.</param>
             <param name="is_extended">Select 29-bit CAN identifiers.</param>
             <returns><see cref="F:Kvaser.CanLib.Canlib.canStatus.canOK"/> if success else canStatus.canERR_XXX.</returns>
        </member>
        <member name="M:Kvaser.CanLib.Canlib.canSetBitrate(System.Int32,System.Int32)">
            <summary>
            The <see cref="M:Kvaser.CanLib.Canlib.canSetBitrate(System.Int32,System.Int32)"/> function sets the nominal bit rate of the specified CAN channel. The sampling point is recalculated and
            kept as close as possible to the value before the call.
            </summary>
            <param name="hnd">An open handle to a CAN channel.</param>
            <param name="bitrate">The new bit rate, in bits/second.</param>
            <returns><see cref="F:Kvaser.CanLib.Canlib.canStatus.canOK"/> if success else canStatus.canERR_XXX.</returns>
        </member>
        <member name="M:Kvaser.CanLib.Canlib.canSetBusOutputControl(System.Int32,System.Int32)">
            <summary>
            This function sets the driver type for a CAN controller. This corresponds
            loosely to the bus output control register in the CAN controller, hence the
            name of this function. CANlib does not allow for direct manipulation of the
            bus output control register; instead, symbolic constants are used to select
            the desired driver type.
            </summary>
            <param name="handle"> An open handle to a CAN channel.</param>
            <param name="drivertype"> Can driver type, canDRIVER_xxx).</param>
            <returns><see cref="F:Kvaser.CanLib.Canlib.canStatus.canOK"/> if success else canStatus.canERR_XXX.</returns>
        </member>
        <member name="M:Kvaser.CanLib.Canlib.canSetBusParams(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
             <summary>
             This function sets the nominal bus timing parameters for the specified CAN
             controller.
             The library provides default values for tseg1, tseg2, sjw and noSamp when
             freq is specified to one of the pre-defined constants,
             canBITRATE_xxx for classic CAN and canFD_BITRATE_xxx for CAN FD.
            
             If freq is any other value, no default values are supplied by the
             library.
            
             If you are using multiple handles to the same physical channel, for example
             if you are writing a threaded application, you must call <see cref="M:Kvaser.CanLib.Canlib.canBusOff(System.Int32)"/> once
             for each handle.The same applies to <see cref="M:Kvaser.CanLib.Canlib.canBusOn(System.Int32)"/> - the physical channel will
             not go off bus until the last handle to the channel goes off bus.
            
             Note: The value of sjw should normally be less than tseg1 and tseg2.
            
              Use <see cref="M:Kvaser.CanLib.Canlib.canSetBusParamsC200(System.Int32,System.Byte,System.Byte)"/> to set the bus timing parameters in the
              ubiquitous 82c200 bit-timing register format.
             </summary>
             <param name="handle"> An open handle to a CAN channel.</param>
             <param name="freq">  Bit rate (measured in bits per second); or one of the
                                  predefined constants(canBITRATE_xxx for classic
                                  CAN and canFD_BITRATE_xxx for CAN FD).</param>
             <param name="tseg1"> Time segment 1, that is, the number of quanta from (but not
                                  including) the Sync Segment to the sampling point.</param>
             <param name="tseg2"> Time segment 2, that is, the number of quanta from the sampling
                                  point to the end of the bit.</param>
             <param name="sjw">      The Synchronization Jump Width.</param>
             <param name="noSamp">   The number of sampling points; can be 1 or 3.</param>
             <returns><see cref="F:Kvaser.CanLib.Canlib.canStatus.canOK"/> if success else canStatus.canERR_XXX.</returns>
        </member>
        <member name="M:Kvaser.CanLib.Canlib.canSetBusParamsC200(System.Int32,System.Byte,System.Byte)">
             <summary>
             This function sets the bus timing parameters using the same convention as the 82c200 CAN controller (which is the same as many
             other CAN controllers, for example, the 82527.)
             To calculate the bit timing parameters, you can use the bit timing calculator that is included with CANlib SDK. Look in the BIN directory.
            
             82c200 Bit Timing
             btr0 [b7..b6]: SJW - 1
             btr0 [b5..b0]: Prescaler -1
             btr1 [b7]: 1: 3 samples, 0: 1 samples
             btr1 [b6..b4]: tseg2 - 1
             btr1 [b3..b0]: tseg1 - 2
            
             Note: CANlib will always behave as if the clock frequency is 16 MHz. It does not matter if the device has a different physical clock,
             since this will be compensated for by the driver.
             </summary>
             <param name="hnd">A handle to an open CAN circuit.</param>
             <param name="btr0">The desired bit timing, formatted as the contents of the BTR0 register in the 82c200.</param>
             <param name="btr1">The desired bit timing, formatted as the contents of the BTR1 register in the 82c200.</param>
             <returns><see cref="F:Kvaser.CanLib.Canlib.canStatus.canOK"/> if success else canStatus.canERR_XXX.</returns>
        </member>
        <member name="M:Kvaser.CanLib.Canlib.canSetBusParamsFd(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
             <summary>
             This function sets the data phase bus timing parameters for the specified
             CAN controller.
            
             The library provides default values for tseg1, tseg2 and
             sjw when freq is specified to one of the pre-defined
             constants, canFD_BITRATE_xxx.
             </summary>
             <param name="handle">An open handle to a CAN channel.</param>
             <param name="freq">CAN FD data bit rate (measured in bits per second); or
                                      one of the predefined constants canFD_BITRATE_xxx.</param>
             <param name="tseg1">Time segment 1, that is, the number of quanta from (but not
                                      including) the Sync Segment to the sampling point.</param>
             <param name="tseg2">Time segment 2, that is, the number of quanta from the sampling
                                      point to the end of the bit.</param>
             <param name="sjw">The Synchronization Jump Width.</param>
             <returns><see cref="F:Kvaser.CanLib.Canlib.canStatus.canOK"/> if success else canStatus.canERR_XXX.</returns>
        </member>
        <member name="M:Kvaser.CanLib.Canlib.canSetBusParamsTq(System.Int32,Kvaser.CanLib.Canlib.kvBusParamsTq)">
             <summary>
             Set bus parameters for the specified CAN controller (classic CAN).
             If the channel is opened(see <see cref="M:Kvaser.CanLib.Canlib.canOpenChannel(System.Int32,System.Int32)"/>) with flags <see cref="F:Kvaser.CanLib.Canlib.canOPEN_CAN_FD"/> or <see cref="F:Kvaser.CanLib.Canlib.canOPEN_CAN_FD_NONISO"/>,
             use <see cref="M:Kvaser.CanLib.Canlib.canSetBusParamsFdTq(System.Int32,Kvaser.CanLib.Canlib.kvBusParamsTq,Kvaser.CanLib.Canlib.kvBusParamsTq)"/> instead.
             <remarks>Constraints that must be fulfilled:
             <c>nominal.tq   = 1 + nominal.prop + nominal.phase1 + nominal.phase2</c>
             <c>nominal.tq  &#8805; 3</c>
             <c>nominal.sjw &#8804; min(nominal.phase1, nominal.phase2)</c>
             <c>1   &#8804; nominal.prescaler &#8804; 2</c></remarks>
            
             To get device specific limits of bus parameters, see <see cref="F:Kvaser.CanLib.Canlib.canCHANNELDATA_BUS_PARAM_LIMITS"/>.
             </summary>
             <param name="hnd">An open handle to a CAN channel.</param>
             <param name="nominal">Structure holding all Nominal values.</param>
             <returns><see cref="F:Kvaser.CanLib.Canlib.canStatus.canOK"/> if success else canStatus.canERR_XXX.</returns>
        </member>
        <member name="M:Kvaser.CanLib.Canlib.canGetBusParamsTq(System.Int32,Kvaser.CanLib.Canlib.kvBusParamsTq@)">
            <summary>
            Get bus parameters for the specified CAN controller.
            If the channel is opened (see <see cref="M:Kvaser.CanLib.Canlib.canOpenChannel(System.Int32,System.Int32)"/>) with flags <see cref="F:Kvaser.CanLib.Canlib.canOPEN_CAN_FD"/> or <see cref="F:Kvaser.CanLib.Canlib.canOPEN_CAN_FD_NONISO"/>, use <see cref="M:Kvaser.CanLib.Canlib.canGetBusParamsFdTq(System.Int32,Kvaser.CanLib.Canlib.kvBusParamsTq@,Kvaser.CanLib.Canlib.kvBusParamsTq@)"/> instead.
            </summary>
            <param name="hnd">An open handle to a CAN channel.</param>
            <param name="nominal">Structure holding bus parameters.</param>
            <returns><see cref="F:Kvaser.CanLib.Canlib.canStatus.canOK"/> if success else canStatus.canERR_XXX.</returns>
        </member>
        <member name="M:Kvaser.CanLib.Canlib.canSetBusParamsFdTq(System.Int32,Kvaser.CanLib.Canlib.kvBusParamsTq,Kvaser.CanLib.Canlib.kvBusParamsTq)">
             <summary>
             Set bus parameters for the specified CAN controller.
             Use if the channel is opened(see <see cref="M:Kvaser.CanLib.Canlib.canOpenChannel(System.Int32,System.Int32)"/>) with flags <see cref="F:Kvaser.CanLib.Canlib.canOPEN_CAN_FD"/> or <see cref="F:Kvaser.CanLib.Canlib.canOPEN_CAN_FD_NONISO"/>, use <see cref="M:Kvaser.CanLib.Canlib.canGetBusParamsTq(System.Int32,Kvaser.CanLib.Canlib.kvBusParamsTq@)"/> otherwise.
             <remarks>
             Constraints that must be fulfilled:
             <c>nominal.tq   = 1 + nominal.prop + nominal.phase1 + nominal.phase2</c>
             <c>nominal.tq  &#8805; 3</c>
             <c>nominal.sjw &#8804; min(nominal.phase1, nominal.phase2)</c>
             <c>1   &#8804; nominal.prescaler &#8804; 2</c>
             <c>data.sjw &#8804; min(data.phase1, data.phase2)</c>
             <c>data.tq   = 1 + data.phase1 + data.phase2</c>
             <c>data.tq  &#8805; 3</c>
             <c>data.prescaler  = nominal.prescaler</c>
             <c>data.prop   = 0</c>
             </remarks>
            
             To get device specific limits of bus parameters, see <see cref="F:Kvaser.CanLib.Canlib.canCHANNELDATA_BUS_PARAM_LIMITS"/>.
             </summary>
             <param name="hnd">An open handle to a CAN channel.</param>
             <param name="nominal">Structure holding bus parameters for arbitration phase.</param>
             <param name="data">Structure holding bus parameters for data phase.</param>
             <returns><see cref="F:Kvaser.CanLib.Canlib.canStatus.canOK"/> if success else canStatus.canERR_XXX.</returns>
        </member>
        <member name="M:Kvaser.CanLib.Canlib.canGetBusParamsFdTq(System.Int32,Kvaser.CanLib.Canlib.kvBusParamsTq@,Kvaser.CanLib.Canlib.kvBusParamsTq@)">
            <summary>
            Get bus parameters for the specified CAN controller.
            Use if the channel is opened(see <see cref="M:Kvaser.CanLib.Canlib.canOpenChannel(System.Int32,System.Int32)"/>) with flags <see cref="F:Kvaser.CanLib.Canlib.canOPEN_CAN_FD"/> or <see cref="F:Kvaser.CanLib.Canlib.canOPEN_CAN_FD_NONISO"/>, use <see cref="M:Kvaser.CanLib.Canlib.canGetBusParamsTq(System.Int32,Kvaser.CanLib.Canlib.kvBusParamsTq@)"/> otherwise.
            </summary>
            <param name="hnd">An open handle to a CAN channel.</param>
            <param name="nominal">Structure holding all Nominal values.</param>
            <param name="data">Structure holding all Data values.</param>
            <returns><see cref="F:Kvaser.CanLib.Canlib.canStatus.canOK"/> if success else canStatus.canERR_XXX.</returns>
        </member>
        <member name="M:Kvaser.CanLib.Canlib.canSetDriverMode(System.Int32,System.Int32,System.Int32)">
             <summary>
             This function sets the current CAN bus driver mode. This is typically a mode like sleep, wakeup, standby, fast mode, etc.
             The different modes are almost always hardware dependent and requires special DRVcan cables. As an example, the DRVcan S
             implements J2411 compliant single-wire CAN and supports four line modes, namely Normal, Sleep, Fast and Wakeup.
            
             Standard ISO 11898 CAN do not support any of these bus driver modes.
            
             Note: The bus driver mode is typically used to control things like one- or two-wire mode, sleep mode, and so on. It requires
             special support in the CAN driver circuit.
             </summary>
             <param name="hnd">An open handle to a CAN circuit.</param>
             <param name="lineMode">An int which defines the line mode, canTRANSCEIVER_LINEMODE_xxx.</param>
             <param name="resNet">An int which defines the resnet mode. Set this parameter to <see cref="F:Kvaser.CanLib.Canlib.canTRANSCEIVER_RESNET_NA"/> unless you have good
             reasons to set it to something else.</param>
             <returns><see cref="F:Kvaser.CanLib.Canlib.canStatus.canOK"/> if success else canStatus.canERR_XXX.</returns>
        </member>
        <member name="M:Kvaser.CanLib.Canlib.canSetNotify(System.Int32,System.IntPtr,System.Int32)">
             <summary>
             This function associates a window handle with the CAN circuit. A WM__CANLIB message is sent to that window when certain events
             (specified by the canNOTIFY_xxx flags) occur.
            
             When an event take place, a WM__CANLIB message will be sent to the window whose handle is aHWnd. This WM__CANLIB message will have:
             * WPARAM handle to the circuit where the event occurred
             * HIWORD(LPARAM) 0
             * LOWORD(LPARAM) canEVENT_xxx
            
             In the routine that handles WM__CANLIB, you can call the CANlib API functions (for example, <see cref="M:Kvaser.CanLib.Canlib.canRead(System.Int32,System.Int32@,System.Byte[],System.Int32@,System.Int32@,System.Int64@)"/>) using the handle found in wParam.
            
             In the routine that handles WM__CANLIB, you must call <see cref="M:Kvaser.CanLib.Canlib.canRead(System.Int32,System.Int32@,System.Byte[],System.Int32@,System.Int32@,System.Int64@)"/> repeatedly until it returns canERR_NOMSG, regardless of the LPARAM value.
             This will flush the driver's internal event queues. If you fail to do this, no more events will be reported.
             </summary>
             <param name="handle">A handle to an open CAN circuit.</param>
             <param name="win_handle">Handle of the window which will receive the notification messages.</param>
             <param name="aNotifyFlags">The events specified with canNOTIFY_xxx, for which callback should be called.</param>
             <returns><see cref="F:Kvaser.CanLib.Canlib.canStatus.canOK"/> if success else canStatus.canERR_XXX.</returns>
        </member>
        <member name="M:Kvaser.CanLib.Canlib.canTranslateBaud(System.Int32,System.Int32@,System.Int32@,System.Int32@,System.Int32@,System.Int32@)">
            <summary>
            This function translates the canBITRATE_xxx constants to their corresponding bus parameter values. At return, this freq
            contains the actual bit rate (in bits per second). TSeg1 is the number of quanta (less one) in a bit before the sampling
            point. TSeg2 is the number of quanta after the sampling point.
            </summary>
            <param name="bitrate">An int which contains the canBITRATE_xxx constant to translate.</param>
            <param name="freq">Frequency value.</param>
            <param name="tseg1">Time segment 1, that is, the number of quanta from (but not
            including) the Sync Segment to the sampling point. </param>
            <param name="tseg2">Time segment 2, that is, the number of quanta from the sampling
            point to the end of the bit. </param>
            <param name="sjw">Synchronization Jump Width. </param>
            <param name="nosamp">Number of sampling points. </param>
            <returns><see cref="F:Kvaser.CanLib.Canlib.canStatus.canOK"/> if success else canStatus.canERR_XXX.</returns>
        </member>
        <member name="M:Kvaser.CanLib.Canlib.kvBitrateToBusParamsTq(System.Int32,System.Int32,Kvaser.CanLib.Canlib.kvBusParamsTq@)">
            <summary>
            This function initializes a kvBusParamsTq object from a canBITRATE_xxx constant.
            </summary>
            <param name="hnd">A handle to an open CAN circuit.</param>
            <param name="freq">An int which contains the canBITRATE_xxx constant to translate.</param>
            <param name="nominal">kvBusParamsTq object that will be initialized.</param>
            <returns><see cref="F:Kvaser.CanLib.Canlib.canStatus.canOK"/> if success else canStatus.canERR_XXX.</returns>
        </member>
        <member name="M:Kvaser.CanLib.Canlib.kvBitrateToBusParamsFdTq(System.Int32,System.Int32,System.Int32,Kvaser.CanLib.Canlib.kvBusParamsTq@,Kvaser.CanLib.Canlib.kvBusParamsTq@)">
            <summary>
            This function initializes a kvBusParamsTq object from canFD_BITRATE_xxx constants.
            </summary>
            <param name="hnd">A handle to an open CAN circuit.</param>
            <param name="freqA">An int which contains the canFD_BITRATE_xxx arbitration bitrate constant to translate.</param>
            <param name="freqD">An int which contains the canFD_BITRATE_xxx data bitrate constant to translate.</param>
            <param name="arbitration">kvBusParamsTq object that will be initialized for the arbitration bitrate.</param>
            <param name="data">kvBusParamsTq object that will be initialized for the data bitrate.</param>
            <returns><see cref="F:Kvaser.CanLib.Canlib.canStatus.canOK"/> if success else canStatus.canERR_XXX.</returns>
        </member>
        <member name="M:Kvaser.CanLib.Canlib.canWaitForEvent(System.Int32,System.Int64)">
            <summary>
            Waits for an event (of any kind) to happen at the specified CAN circuit, or a timeout to occur. An event in this context means
            for example the arrival of a CAN message or a CAN bus status change, but it can also be an event internal to the driver.
            </summary>
            <param name="hnd">A handle to an open CAN circuit.</param>
            <param name="timeout">The number of milliseconds to wait before the call returns, if no event occurs. 0xFFFFFFFF gives an
            infinite timeout.</param>
            <returns><see cref="F:Kvaser.CanLib.Canlib.canStatus.canOK"/> (zero) if success. <see cref="F:Kvaser.CanLib.Canlib.canStatus.canERR_TIMEOUT"/> (negative) if nothing happened during the specified time period.
            canERR_xxx (negative) if failure</returns>
        </member>
        <member name="M:Kvaser.CanLib.Canlib.canWrite(System.Int32,System.Int32,System.Byte[],System.Int32,System.Int32)">
             <summary>
             This function sends a CAN message. The call returns immediately after queuing the message to the driver.
            
             If you are using the same channel via multiple handles, note that the default behaviour is that the
             different handles will "hear" each other just as if each handle referred to a channel of its own. If you
             open, say, channel 0 from thread A and thread B and then send a message from thread A, it will be "received"
             by thread B. This behaviour can be changed using <see cref="F:Kvaser.CanLib.Canlib.canIOCTL_SET_LOCAL_TXECHO"/>.
            <para>&#160;</para>
             Note
             The message has been queued for transmission when this calls return. It has not necessarily been sent.
             </summary>
             <param name="handle">A handle to an open CAN circuit.</param>
             <param name="id">The identifier of the CAN message to send.</param>
             <param name="msg">A reference to the message data.</param>
             <param name="dlc">The length of the message in bytes.
             For Classic CAN dlc can be at most 8, unless <see cref="F:Kvaser.CanLib.Canlib.canOPEN_ACCEPT_LARGE_DLC"/> is used.
             For CAN FD dlc can be one of the following 0-8, 12, 16, 20, 24, 32, 48, 64.</param>
             <param name="flag">A combination of message flags, canMSG_xxx (including canFDMSG_xxx if the CAN FD protocol
             is enabled). Use this parameter to send extended (29-bit) frames and/or remote frames. Use <see cref="F:Kvaser.CanLib.Canlib.canMSG_EXT"/> and/or
             <see cref="F:Kvaser.CanLib.Canlib.canMSG_RTR"/> for this purpose.</param>
             <returns><see cref="F:Kvaser.CanLib.Canlib.canStatus.canOK"/> if success else canStatus.canERR_XXX.</returns>
        </member>
        <member name="M:Kvaser.CanLib.Canlib.canWriteSync(System.Int32,System.Int64)">
            <summary>
            Waits until all CAN messages for the specified handle are sent, or the timeout period expires.
            </summary>
            <param name="handle">A handle to an open CAN circuit.</param>
            <param name="timeout">The timeout in milliseconds. 0xFFFFFFFF gives an infinite timeout.</param>
            <returns><see cref="F:Kvaser.CanLib.Canlib.canStatus.canOK"/> (zero) if the queue emptied before the timeout period came to its end.
            <see cref="F:Kvaser.CanLib.Canlib.canStatus.canERR_TIMEOUT"/> (negative) not all messages were transmitted when the timeout occurred.
            <see cref="F:Kvaser.CanLib.Canlib.canStatus.canERR_PARAM"/> (negative) This could be caused by an erroneous parameter, or if you have turned TXACKs off (by using <see cref="M:Kvaser.CanLib.Canlib.canIoCtl(System.Int32,System.Int32,System.Object@)"/>)
            because if you do you can't use this call. The driver simply doesn't know when all the messages are sent!
            canERR_xxx (negative) if failure</returns>
        </member>
        <member name="M:Kvaser.CanLib.Canlib.canWriteWait(System.Int32,System.Int32,System.Byte[],System.Int32,System.Int32,System.Int64)">
             <summary>
             This function sends a CAN message. It returns when the message is sent, or the timeout expires.
            
             This is a convenience function that combines <see cref="M:Kvaser.CanLib.Canlib.canWrite(System.Int32,System.Int32,System.Byte[],System.Int32,System.Int32)"/> and <see cref="M:Kvaser.CanLib.Canlib.canWriteSync(System.Int32,System.Int64)"/>.
            
             If you are using the same channel via multiple handles, note that the default behaviour is that the different handles will
             "hear" each other just as if each handle referred to a channel of its own. If you open, say, channel 0 from thread A and
             thread B and then send a message from thread A, it will be "received" by thread B. This behaviour can be changed using
             <see cref="F:Kvaser.CanLib.Canlib.canIOCTL_SET_LOCAL_TXECHO"/>.
             </summary>
             <param name="handle">A handle to an open CAN circuit.</param>
             <param name="id">The identifier of the CAN message to send.</param>
             <param name="msg">A reference to the message data.</param>
             <param name="dlc">The length of the message in bytes.
             For Classic CAN dlc can be at most 8, unless <see cref="F:Kvaser.CanLib.Canlib.canOPEN_ACCEPT_LARGE_DLC"/> is used.
             For CAN FD dlc can be one of the following 0-8, 12, 16, 20, 24, 32, 48, 64.</param>
             <param name="flag">A combination of message flags, canMSG_xxx (including canFDMSG_xxx if the CAN FD protocol
             is enabled). Use this parameter to send extended (29-bit) frames and/or remote frames. Use canMSG_EXT and/or
             canMSG_RTR for this purpose.</param>
             <param name="timeout">The timeout, in milliseconds. 0xFFFFFFFF gives an infinite timeout.</param>
             <returns><see cref="F:Kvaser.CanLib.Canlib.canStatus.canOK"/> if success else canStatus.canERR_XXX.</returns>
        </member>
        <member name="M:Kvaser.CanLib.Canlib.canUnloadLibrary">
            <summary>
             Use this function if you are loading canlib32.dll dynamically (that is, using the Win32 API LoadLibrary)
             and need to unload it using the Win32 API FreeLibrary. <see cref="M:Kvaser.CanLib.Canlib.canUnloadLibrary"/> will free allocated memory,
             unload the DLLs canlib32.dll has loaded and de-initialize data structures.
             You must call <see cref="M:Kvaser.CanLib.Canlib.canInitializeLibrary"/> again to use the API functions in canlib32.dll.
            </summary>
            <returns><see cref="F:Kvaser.CanLib.Canlib.canStatus.canOK"/> if success else canStatus.canERR_XXX.</returns>
        </member>
        <member name="M:Kvaser.CanLib.Canlib.GetUTF8Bytes(System.String)">
            <summary>
                Create a byte[] containing the utf-8 representation of string stringValue and a terminating'\0' character.
            </summary>
        </member>
        <member name="M:Kvaser.CanLib.Canlib.GetUTF8String(System.Byte[])">
            <summary>
                Convert byte[] contents to a string object using the utf-8 decoder.
            </summary>
        </member>
        <member name="M:Kvaser.CanLib.Canlib.CANSTATUS_SUCCESS(System.Int32)">
            <summary>
            Evaluate status code value as an int.
            </summary>
            <param name="X">status as int value.</param>
            <returns>1 if x is equal to int value of canStatus.canOK else 0.</returns>
        </member>
        <member name="M:Kvaser.CanLib.Canlib.CANSTATUS_FAILURE(System.Int32)">
            <summary>
            Evaluate status code value as an int.
            </summary>
            <param name="X">status as int value.</param>
            <returns>0 if x is equal to int value of canStatus.canOK else 1.</returns>
        </member>
        <member name="M:Kvaser.CanLib.Canlib.kvAnnounceIdentity(System.Int32,System.Object)">
            <summary>
            The <see cref="M:Kvaser.CanLib.Canlib.kvAnnounceIdentity(System.Int32,System.Object)"/> function is used by certain OEM applications.
            </summary>
            <param name="hnd">An open handle to a CAN channel.</param>
            <param name="buffer"> Data to send to driver.</param>
            <returns><see cref="F:Kvaser.CanLib.Canlib.canStatus.canOK"/> if success else canStatus.canERR_XXX.</returns>
        </member>
        <member name="M:Kvaser.CanLib.Canlib.kvAnnounceIdentityEx(System.Int32,System.Int32,System.Byte[])">
            <summary>
            The <see cref="M:Kvaser.CanLib.Canlib.kvAnnounceIdentityEx(System.Int32,System.Int32,System.Byte[])"/> function is used by certain OEM applications.
            </summary>
            <param name="hnd">An open handle to a CAN channel.</param>
            <param name="type"> Type of announcement.</param>
            <param name="data"> Data to send to driver.</param>
            <returns><see cref="F:Kvaser.CanLib.Canlib.canStatus.canOK"/> if success else canStatus.canERR_XXX.</returns>
        </member>
        <member name="M:Kvaser.CanLib.Canlib.kvBeep(System.Int32,System.Int32,System.Int32)">
            <summary>
            Emit a sound of a specific frequency and duration from the loudspeaker on the device.
            <para>&#160;</para>
            Note: This function requires that a loudspeaker be present on the hardware.
            </summary>
            <param name="hnd">An open handle to a CAN channel.</param>
            <param name="freq"> The frequency (in Hertz) of the sound.</param>
            <param name="duration"> The duration of the sound, in milliseconds.</param>
            <returns><see cref="F:Kvaser.CanLib.Canlib.canStatus.canOK"/> if success else canStatus.canERR_XXX.</returns>
        </member>
        <member name="M:Kvaser.CanLib.Canlib.kvDeviceGetMode(System.Int32,System.Int32@)">
            <summary>
            The <see cref="M:Kvaser.CanLib.Canlib.kvDeviceGetMode(System.Int32,System.Int32@)"/> reads the current device's specific mode.
            </summary>
            <param name="hnd">An open handle to a CAN channel.</param>
            <param name="result"> A pointer to a 32-bit integer that will receive the kvDEVICE_MODE_xxx value.</param>
            <returns><see cref="F:Kvaser.CanLib.Canlib.canStatus.canOK"/> if success else canStatus.canERR_XXX.</returns>
        </member>
        <member name="M:Kvaser.CanLib.Canlib.kvDeviceSetMode(System.Int32,System.Int32)">
            <summary>
            The <see cref="M:Kvaser.CanLib.Canlib.kvDeviceSetMode(System.Int32,System.Int32)"/> sets the mode.
            </summary>
            <param name="hnd">An open handle to a CAN channel.</param>
            <param name="mode">One of the kvDEVICE_MODE_xxx constants, defining which mode to use.</param>
            <returns><see cref="F:Kvaser.CanLib.Canlib.canStatus.canOK"/> if success else canStatus.canERR_XXX.</returns>
        </member>
        <member name="M:Kvaser.CanLib.Canlib.kvFileCopyFromDevice(System.Int32,System.String,System.String)">
            <summary>
            Copy an arbitrary file from the device to the host.
            </summary>
            <param name="hnd">An open handle to a CAN channel.</param>
            <param name="deviceFileName">The device file name.</param>
            <param name="hostFileName"> The target host file name.</param>
            <returns><see cref="F:Kvaser.CanLib.Canlib.canStatus.canOK"/> if success else canStatus.canERR_XXX.</returns>
        </member>
        <member name="M:Kvaser.CanLib.Canlib.kvFileCopyToDevice(System.Int32,System.String,System.String)">
            <summary>
            Copy an arbitrary file from the host to the device.
            </summary>
            <param name="hnd">An open handle to a CAN channel.</param>
            <param name="hostFileName">The host file name.</param>
            <param name="deviceFileName">The target device file name.</param>
            <returns><see cref="F:Kvaser.CanLib.Canlib.canStatus.canOK"/> if success else canStatus.canERR_XXX.</returns>
        </member>
        <member name="M:Kvaser.CanLib.Canlib.kvFileDelete(System.Int32,System.String)">
            <summary>
            This function deletes a file on the device
            </summary>
            <param name="hnd">An open handle to a CAN channel.</param>
            <param name="deviceFileName">The file on the device to delete.</param>
            <returns><see cref="F:Kvaser.CanLib.Canlib.canStatus.canOK"/> if success else canStatus.canERR_XXX.</returns>
        </member>
        <member name="M:Kvaser.CanLib.Canlib.kvFileGetCount(System.Int32,System.Int32@)">
            <summary>
            Get the number of files.
            </summary>
            <param name="hnd">An open handle to a CAN channel.</param>
            <param name="count">The number of files on the device.</param>
            <returns><see cref="F:Kvaser.CanLib.Canlib.canStatus.canOK"/> if success else canStatus.canERR_XXX.</returns>
        </member>
        <member name="M:Kvaser.CanLib.Canlib.kvFileGetName(System.Int32,System.Int32,System.String@)">
            <summary>
            Returns the name of the file with number fileNo.
            </summary>
            <param name="hnd">An open handle to a CAN channel.</param>
            <param name="fileNo">The number of the file.</param>
            <param name="name">Name of the file as a string</param>
            <returns><see cref="F:Kvaser.CanLib.Canlib.canStatus.canOK"/> if success else canStatus.canERR_XXX.</returns>
        </member>
        <member name="M:Kvaser.CanLib.Canlib.kvFileGetSystemData(System.Int32,System.Int32,System.Int32@)">
            <summary>
            Read disk parameters
            <para>&#160;</para>
            Note: Not yet implemented
            </summary>
            <param name="hnd">An open handle to a CAN channel.</param>
            <param name="itemCode">The item we want information on.</param>
            <param name="result">A pointer to a 32-bit integer that will receive the result.</param>
            <returns><see cref="F:Kvaser.CanLib.Canlib.canStatus.canOK"/> if success else canStatus.canERR_XXX.</returns>
        </member>
        <member name="M:Kvaser.CanLib.Canlib.kvFlashLeds(System.Int32,System.Int32,System.Int32)">
            <summary>
            Turn the LEDs on the device on or off.
            </summary>
            <param name="hnd">An open handle to a CAN channel.</param>
            <param name="action"> One of the kvLED_ACTION_xxx constants, defining which LED to turn on or off. </param>
            <param name="timeout"> Specifies the time, in milliseconds, during which the action is to be carried out. When the timeout expires the LED(s) will return to its ordinary function.</param>
            <returns><see cref="F:Kvaser.CanLib.Canlib.canStatus.canOK"/> if success else canStatus.canERR_XXX.</returns>
        </member>
        <member name="M:Kvaser.CanLib.Canlib.kvGetApplicationMapping(System.Int32,System.String,System.Int32,System.Int32@)">
            <summary>
            Note: The kvGetApplicationMapping function is presently not implemented.
            </summary>
            <param name="busType"></param>
            <param name="appName"></param>
            <param name="appChannel"></param>
            <param name="resultingChannel"></param>
            <returns><see cref="F:Kvaser.CanLib.Canlib.canStatus.canOK"/> if success else canStatus.canERR_XXX.</returns>
        </member>
        <member name="M:Kvaser.CanLib.Canlib.kvGetSupportedInterfaceInfo(System.Int32,System.String@,System.Int32@,System.Int32@)">
             <summary>
             The <see cref="M:Kvaser.CanLib.Canlib.kvGetSupportedInterfaceInfo(System.Int32,System.String@,System.Int32@,System.Int32@)"/> function returns information about the different supported hardware types in the installed version of CANlib.
             This function is used to enumerate all the supported hardware types in the installed version of CANlib. It does not return a complete list of all supported devices, nor does it return a list of the presently installed hardware. The returned data indicates which device families are supported.
             <para>&#160;</para>
             For example, a returned set of data might be:<para>&#160;</para>
             hwType = <see cref="F:Kvaser.CanLib.Canlib.canHWTYPE_MEMORATOR_PRO"/><para>&#160;</para>
             hwBusType = <see cref="F:Kvaser.CanLib.Canlib.kvBUSTYPE_USB"/><para>&#160;</para>
             hwName = "Kvaser Memorator Professional"<para>&#160;</para>
             This means that<para>&#160;</para>
            the presently installed version of CANlib supports members in the Kvaser Memorator Pro family(e.g.the HS/HS and the HS/LS),<para>&#160;</para>
            the members of the Kvaser Memorator Pro family are USB devices,<para>&#160;</para>
            the members of the Kvaser Memorator Pro family use the <see cref="F:Kvaser.CanLib.Canlib.canHWTYPE_MEMORATOR_PRO"/> hardware type.
            The kvGetSupportedInterfaceInfo() function is intended to help application designers build a bus-oriented display of the different installed and/or supported Kvaser devices in the computer.
            <para>&#160;</para>
            Note: Not inplemented in linux.
             </summary>
             <param name="index">Use this parameter to enumerate the different supported hardware types. Start with index = 0, and then call
                                 <see cref="M:Kvaser.CanLib.Canlib.kvGetSupportedInterfaceInfo(System.Int32,System.String@,System.Int32@,System.Int32@)"/> again() with index = 1,2,3,... until the function returns an error code.</param>
             <param name="hwName">Name of the hardware family.</param>
             <param name="hwType">Hardware type as a canHWTYPE_xxx.</param>
             <param name="hwBusType">Bus type as a kvBUSTYPE_xxx.</param>
             <returns><see cref="F:Kvaser.CanLib.Canlib.canStatus.canOK"/> if success else canStatus.canERR_XXX.</returns>
        </member>
        <member name="M:Kvaser.CanLib.Canlib.kvIoConfirmConfig(System.Int32)">
            <summary>
            This function is used to confirm configuration. It is required to call this function, before it is
            possible to use any kvIoPinSetXxx()/kvIoPinGetXxx() function. After a configuration change, module removal
            or insertion, it is required to confirm the new configuration.
            /// <para>&#160;</para>
            Note:
            Preliminary API that may change. Not implemented in Linux.
            </summary>
            <param name="handle">An open handle to a CAN channel.</param>
            <returns><see cref="F:Kvaser.CanLib.Canlib.canStatus.canOK"/> if success else canStatus.canERR_XXX.</returns>
        </member>
        <member name="M:Kvaser.CanLib.Canlib.kvIoPinGetAnalog(System.Int32,System.Int32,System.Single@)">
            <summary>
            This function is used to retrieve the voltage level of the specified analog I/O pin.
            <para>&#160;</para>
            Note:
            Preliminary API that may change. Not implemented in Linux.
            </summary>
            <param name="handle">An open handle to a CAN channel.</param>
            <param name="pin">The pin number, <see cref="M:Kvaser.CanLib.Canlib.kvIoGetNumberOfPins(System.Int32,System.Int32@)"/>.</param>
            <param name="value">A reference to a float which receives the voltage of the pin.</param>
            <returns><see cref="F:Kvaser.CanLib.Canlib.canStatus.canOK"/> if success else canStatus.canERR_XXX.</returns>
        </member>
        <member name="M:Kvaser.CanLib.Canlib.kvIoPinGetDigital(System.Int32,System.Int32,System.Int32@)">
            <summary>
            This function is used to retrieve the value of the specified digital input I/O pin.
            If the pin is LOW, the integer pointed to by value is assigned zero. If the pin is HIGH,
            the integer pointed to by value is assigned a '1'.
            <para>&#160;</para>
            Note:
            Preliminary API that may change. Not implemented in Linux.
            </summary>
            <param name="handle">An open handle to a CAN channel.</param>
            <param name="pin">The pin number, <see cref="M:Kvaser.CanLib.Canlib.kvIoGetNumberOfPins(System.Int32,System.Int32@)"/>.</param>
            <param name="value">A reference to an unsigned int which receives the value of the pin.</param>
            <returns><see cref="F:Kvaser.CanLib.Canlib.canStatus.canOK"/> if success else canStatus.canERR_XXX.</returns>
        </member>
        <member name="M:Kvaser.CanLib.Canlib.kvIoPinGetInfo(System.Int32,System.Int32,Kvaser.CanLib.Canlib.kvIOGetInfo,System.Object@)">
            <summary>
            This function is used to retrieve I/O pin properties.
            <para>&#160;</para>
            Note:
            Preliminary API that may change. Not implemented in Linux.
            </summary>
            <param name="handle">An open handle to a CAN channel.</param>
            <param name="pin">The pin number, <see cref="M:Kvaser.CanLib.Canlib.kvIoGetNumberOfPins(System.Int32,System.Int32@)"/></param>
            <param name="item">Type of item to retrieve, <see cref="T:Kvaser.CanLib.Canlib.kvIOGetInfo"/> .</param>
            <param name="data">Object to store the data in.</param>
            <returns><see cref="F:Kvaser.CanLib.Canlib.canStatus.canOK"/> if success else canStatus.canERR_XXX.</returns>
        </member>
        <member name="M:Kvaser.CanLib.Canlib.kvIoPinGetOutputAnalog(System.Int32,System.Int32,System.Single@)">
            <summary>
            This function is used to get the latest set voltage level of an analog I/O pin. This function only returns
            values as they are presented in memory and the actual value on the output pin may therefore differ.
            <para>&#160;</para>
            Note:
            Preliminary API that may change. Not implemented in Linux.
            </summary>
            <param name="handle">An open handle to a CAN channel.</param>
            <param name="pin">The pin number, <see cref="M:Kvaser.CanLib.Canlib.kvIoGetNumberOfPins(System.Int32,System.Int32@)"/>.</param>
            <param name="value">A reference to a float which receives the latest set voltage level of the pin.</param>
            <returns><see cref="F:Kvaser.CanLib.Canlib.canStatus.canOK"/> if success else canStatus.canERR_XXX.</returns>
        </member>
        <member name="M:Kvaser.CanLib.Canlib.kvIoPinGetOutputDigital(System.Int32,System.Int32,System.Int32@)">
            <summary>
            This function is used to get the latest set value of a digital output I/O pin. If the latest value
            written to the pin is LOW, the integer pointed to by value is assigned zero. If it is HIGH, the
            integer pointed to by value is assigned a '1'. This function only returns values as they are presented
            in memory and the actual value on the output pin may therefore differ.
            <para>&#160;</para>
            Note:
            Preliminary API that may change. Not implemented in Linux.
            </summary>
            <param name="handle">An open handle to a CAN channel.</param>
            <param name="pin">The pin number, <see cref="M:Kvaser.CanLib.Canlib.kvIoGetNumberOfPins(System.Int32,System.Int32@)"/>.</param>
            <param name="value">A reference to an unsigned int which receives the value of the pin.</param>
            <returns><see cref="F:Kvaser.CanLib.Canlib.canStatus.canOK"/> if success else canStatus.canERR_XXX.</returns>
        </member>
        <member name="M:Kvaser.CanLib.Canlib.kvIoPinGetOutputRelay(System.Int32,System.Int32,System.Int32@)">
            <summary>
            This function is used to get the latest set value of a relay I/O pin. If value is zero, the relay has
            been set to OFF. For any non-zero value, the relay has been set to ON. This function returns values
            as they are presented in memory and the actual state on the relay pin may differ.
            <para>&#160;</para>
            Note:
            Preliminary API that may change. Not implemented in Linux.
            </summary>
            <param name="handle">An open handle to a CAN channel.</param>
            <param name="pin">The pin number, <see cref="M:Kvaser.CanLib.Canlib.kvIoGetNumberOfPins(System.Int32,System.Int32@)"/>.</param>
            <param name="value">A reference to an unsigned int which receives the value of the pin.</param>
            <returns><see cref="F:Kvaser.CanLib.Canlib.canStatus.canOK"/> if success else canStatus.canERR_XXX.</returns>
        </member>
        <member name="M:Kvaser.CanLib.Canlib.kvIoGetNumberOfPins(System.Int32,System.Int32@)">
            <summary>
            Get the number of I/O pins available from a device.
            <para>&#160;</para>
            Note:
            Preliminary API that may change. Not implemented in Linux.
            </summary>
            <param name="handle">An open handle to a CAN channel.</param>
            <param name="pinCount">A reference to an int which receives the number of pins.</param>
            <returns><see cref="F:Kvaser.CanLib.Canlib.canStatus.canOK"/> if success else canStatus.canERR_XXX.</returns>
        </member>
        <member name="M:Kvaser.CanLib.Canlib.kvIoPinSetAnalog(System.Int32,System.Int32,System.Single)">
            <summary>
            This function is used to set the voltage level of the specified analog I/O pin.
            <para>&#160;</para>
            Note:
            Preliminary API that may change. Not implemented in Linux.
            </summary>
            <param name="handle">An open handle to a CAN channel.</param>
            <param name="pin">The pin number, <see cref="M:Kvaser.CanLib.Canlib.kvIoGetNumberOfPins(System.Int32,System.Int32@)"/> .</param>
            <param name="value">A float which sets a voltage of the pin.</param>
            <returns><see cref="F:Kvaser.CanLib.Canlib.canStatus.canOK"/> if success else canStatus.canERR_XXX.</returns>
        </member>
        <member name="M:Kvaser.CanLib.Canlib.kvIoPinSetDigital(System.Int32,System.Int32,System.Int32)">
            <summary>
            This function is used to set a digital output I/O pin. If value is zero, the pin is set LOW.
            For any non-zero value, the pin is set HIGH.
            <para>&#160;</para>
            Note:
            Preliminary API that may change. Not implemented in Linux.
            </summary>
            <param name="handle">An open handle to a CAN channel.</param>
            <param name="pin">The pin number, <see cref="M:Kvaser.CanLib.Canlib.kvIoGetNumberOfPins(System.Int32,System.Int32@)"/>. </param>
            <param name="value">An int32 which sets a value of the pin.</param>
            <returns><see cref="F:Kvaser.CanLib.Canlib.canStatus.canOK"/> if success else canStatus.canERR_XXX.</returns>
        </member>
        <member name="M:Kvaser.CanLib.Canlib.kvIoPinSetInfo(System.Int32,System.Int32,Kvaser.CanLib.Canlib.kvIOSetInfo,System.Object)">
            <summary>
            This function is used to set I/O pin properties, for items that can be changed.
            <para>&#160;</para>
            Note:
            Preliminary API that may change. Not implemented in Linux.
            </summary>
            <param name="handle">An open handle to a CAN channel.</param>
            <param name="pin">The pin number, <see cref="M:Kvaser.CanLib.Canlib.kvIoGetNumberOfPins(System.Int32,System.Int32@)"/>.</param>
            <param name="item">Type of item to set, <see cref="T:Kvaser.CanLib.Canlib.kvIOSetInfo"/>.</param>
            <param name="data">The data to set.</param>
            <returns><see cref="F:Kvaser.CanLib.Canlib.canStatus.canOK"/> if success else canStatus.canERR_XXX.</returns>
        </member>
        <member name="M:Kvaser.CanLib.Canlib.kvIoPinSetRelay(System.Int32,System.Int32,System.Int32)">
            <summary>
            This function is used to control a relay of the specified I/O pin. If value is zero, the relay is set to OFF.
            For any non-zero value, the relay is set to ON.
            <para>&#160;</para>
            Note:
            Preliminary API that may change. Not implemented in Linux.
            </summary>
            <param name="handle">An open handle to a CAN channel.</param>
            <param name="pin">The pin number, <see cref="M:Kvaser.CanLib.Canlib.kvIoGetNumberOfPins(System.Int32,System.Int32@)"/> .</param>
            <param name="value">An int which sets a value of the pin.</param>
            <returns><see cref="F:Kvaser.CanLib.Canlib.canStatus.canOK"/> if success else canStatus.canERR_XXX.</returns>
        </member>
        <member name="M:Kvaser.CanLib.Canlib.kvPingGetLatest(System.Int32,System.Int32@,System.Int32@)">
            <summary>This retrieves the latest ping time issued by an earlier call to  <see cref="M:Kvaser.CanLib.Canlib.kvPingRequest(System.Int32,System.Int32@)"/>. </summary>
            <param name="hnd">A handle to an open circuit.</param>
            <param name="requestTime">Time of request in microseconds. Used for matching answer to request.</param>
            <param name="pingTime">Latest value of ping time in milliseconds.</param>
            <returns><see cref="F:Kvaser.CanLib.Canlib.canStatus.canOK"/> if success else canStatus.canERR_XXX.</returns>
        </member>
        <member name="M:Kvaser.CanLib.Canlib.kvPingRequest(System.Int32,System.Int32@)">
            <summary>This function sends an active ping to a device. The ping time can later be retrieved using <see cref="M:Kvaser.CanLib.Canlib.kvPingGetLatest(System.Int32,System.Int32@,System.Int32@)"/>. </summary>
            <param name="hnd">A handle to an open circuit.</param>
            <param name="requestTime">Time of request in microseconds. Used for matching answer to request.</param>
            <returns><see cref="F:Kvaser.CanLib.Canlib.canStatus.canOK"/> if success else canStatus.canERR_XXX.</returns>
        </member>
        <member name="M:Kvaser.CanLib.Canlib.kvIoSetModulePins(System.Int32,System.Int32,System.Object)">
            <summary> 
            This function is used to set all output and relay pins of a module in a single call.
            See also <see cref="M:Kvaser.CanLib.Canlib.kvIoGetModulePins(System.Int32,System.Int32,System.Object)"/>
            <para>&#160;</para>
            Note:
            Preliminary API that may change.
            Not implemented in linux.
            Values for pins of type input are ignored.
            </summary>
            <param name="hnd">An open handle to a CAN channel.</param>
            <param name="module">The module number, see <see cref="F:Kvaser.CanLib.Canlib.kvIOGetInfo.MODULE_NUMBER"/>.</param>
            <param name="buffer">
            An object that contains the module type and pin values to set. The object must correspond to the module type, and can be any one of the following.
            <list type="bullet">
            <item><see cref="T:Kvaser.CanLib.Canlib.kvIoModuleDigital"/></item>
            <item><see cref="T:Kvaser.CanLib.Canlib.kvIoModuleAnalog"/></item>
            <item><see cref="T:Kvaser.CanLib.Canlib.kvIoModuleRelay"/></item>
            <item><see cref="T:Kvaser.CanLib.Canlib.kvIoModuleInternal"/></item>
            </list>
            </param>
            <returns><see cref="F:Kvaser.CanLib.Canlib.canStatus.canOK"/> if success else canStatus.canERR_XXX.</returns>
        </member>
        <member name="M:Kvaser.CanLib.Canlib.kvIoGetModulePins(System.Int32,System.Int32,System.Object)">
            <summary>
            This function is used to read all the pins of one module in a single call.
            See also <see cref="M:Kvaser.CanLib.Canlib.kvIoSetModulePins(System.Int32,System.Int32,System.Object)"/>
            <para>&#160;</para>
            Note:
            Preliminary API that may change.
            Not implemented in linux.
            </summary> 
            <param name="hnd">An open handle to a CAN channel.</param>
            <param name="module">The module number, see <see cref="F:Kvaser.CanLib.Canlib.kvIOGetInfo.MODULE_NUMBER"/>.</param>
            <param name="buffer">An object that receives the type and pin values of the module. The object must correspond to the module type, and can be any of the following.
            <list type="bullet">
            <item><see cref="T:Kvaser.CanLib.Canlib.kvIoModuleDigital"/></item>
            <item><see cref="T:Kvaser.CanLib.Canlib.kvIoModuleAnalog"/></item>
            <item><see cref="T:Kvaser.CanLib.Canlib.kvIoModuleRelay"/></item>
            <item><see cref="T:Kvaser.CanLib.Canlib.kvIoModuleInternal"/></item>
            </list>
            </param>
            <returns><see cref="F:Kvaser.CanLib.Canlib.canStatus.canOK"/> if success else canStatus.canERR_XXX.</returns>
        </member>
        <member name="M:Kvaser.CanLib.Canlib.kvReadDeviceCustomerData(System.Int32,System.Int32,System.Int32,System.Byte[],System.Int32)">
            <summary> Reading customer data works with Kvaser Leaf (of all types), Kvaser USBcan Professional, Kvaser Memorator Professional,
            Kvaser Eagle and Kvaser Memorator Light.To write customer data use external tools.</summary>
            <param name="hnd">An open handle to a CAN channel</param>
            <param name="userNumber">Assigned by Kvaser.</param>
            <param name="itemNumber">Must be zero (reserved)</param>
            <param name="data">A pointer to a buffer of up to 8 bytes where the result will be placed.</param>
            <param name="bufsize">The size of the buffer that data points at.</param>
            <returns><see cref="F:Kvaser.CanLib.Canlib.canStatus.canOK"/> if success else canStatus.canERR_XXX.</returns>
        </member>
        <member name="M:Kvaser.CanLib.Canlib.kvReadTimer(System.Int32,System.Int32@)">
             <summary>
             The kvReadTimer reads the hardware clock on the specified device and returns the value.
            
             When the call to <see cref="M:Kvaser.CanLib.Canlib.kvReadTimer(System.Int32,System.Int32@)"/> returns, the time value is already obsolete.The time required for the device firmware,
             any intermediary buses (like USB,) and the operating system to return the time value is not defined.
            
             </summary>
             <param name="hnd">An open handle to a CAN channel</param>
             <param name="time">Returned timer value</param>
             <returns><see cref="F:Kvaser.CanLib.Canlib.canStatus.canOK"/> if success else canStatus.canERR_XXX.</returns>
        </member>
        <member name="M:Kvaser.CanLib.Canlib.kvReadTimer64(System.Int32,System.Int64@)">
             <summary>
             The kvReadTimer64 reads the hardware clock on the specified device and returns the value.
            
             When the call to <see cref="M:Kvaser.CanLib.Canlib.kvReadTimer64(System.Int32,System.Int64@)"/> returns, the time value is already obsolete.The time required for the device firmware,
             any intermediary buses (like USB,) and the operating system to return the time value is not defined.
             </summary>
             <param name="handle">An open handle to a CAN channel</param>
             <param name="time">Returned timer value</param>
             <returns><see cref="F:Kvaser.CanLib.Canlib.canStatus.canOK"/> if success else canStatus.canERR_XXX.</returns>
        </member>
        <member name="M:Kvaser.CanLib.Canlib.kvScriptLoadFile(System.Int32,System.Int32,System.String)">
            <summary>
            Loads a compiled script file (.txe) stored on the host(PC) into a script slot on the device.
            <para>&#160;</para>
            The canHandle is used to determine what channel is set as the default channel for the loaded script.
            If your canHandle was opened via a device's second channel, the default channel number will be set to 1 (the numbering of channel on the card starts from 0).
            </summary>
            <param name="hnd">An open handle to a CAN channel.</param>
            <param name="slotNo">The slot where to load the script.</param>
            <param name="filePathOnPC">Path to the script file on PC.</param>
            <returns>KvStatus.OK if success else KvStatus.ERR_XXX.</returns>
        </member>
        <member name="M:Kvaser.CanLib.Canlib.kvScriptLoadFileOnDevice(System.Int32,System.Int32,System.String)">
            <summary>
            Loads a compiled script file (.txe) stored on the device (SD card) into a script slot on the device.
            <para>&#160;</para>
            Note. Not implemented in linux.
            </summary>
            <param name="hnd">An open handle to a CAN channel.</param>
            <param name="slotNo">The slot where to load the script.</param>
            <param name="localFile">Path to the script file on PC.</param>
            <returns>KvStatus.OK if success else KvStatus.ERR_XXX.</returns>
        </member>
        <member name="M:Kvaser.CanLib.Canlib.kvScriptSendEvent(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
             Send an event of a type, and an event number and associated data to a script running in a specific slot.
            <para>&#160;</para>
            Note. Not implemented in linux.
            </summary>
            <param name="hnd">An open handle to a CAN channel.</param>
            <param name="slotNo">The slot where to load the script.</param>
            <param name="eventType">The event to send, of type kvEVENT_xxx.</param>
            <param name="eventNo">The event's number.</param>
            <param name="data">The event's data.</param>
            <returns>KvStatus.OK if success else KvStatus.ERR_XXX.</returns>
        </member>
        <member name="M:Kvaser.CanLib.Canlib.kvScriptStart(System.Int32,System.Int32)">
            <summary>
            This routine starts a loaded script.
            </summary>
            <param name="hnd">An open handle to a CAN channel.</param>
            <param name="slotNo">The slot with the loaded script we want to start.</param>
            <returns>KvStatus.OK if success else canStatus.canERR_XXX.</returns>
        </member>
        <member name="M:Kvaser.CanLib.Canlib.kvScriptStatus(System.Int32,System.Int32,System.Int32@)">
            <summary>
            Read the current status of a script slot.
            <para>&#160;</para>
            Note. Not implemented in linux.
            </summary>
            <param name="hnd">An open handle to a CAN channel.</param>
            <param name="slotNo">The slot where to load the script.</param>
            <param name="status">The script status, as kvSCRIPT_STATUS_xxx flag bits.</param>
            <returns>KvStatus.OK if success else KvStatus.ERR_XXX.</returns>
        </member>
        <member name="M:Kvaser.CanLib.Canlib.kvScriptStop(System.Int32,System.Int32,System.Int32)">
            <summary>
            This routine stops a started script.
            </summary>
            <param name="hnd">An open handle to a CAN channel.</param>
            <param name="slotNo">The slot with the loaded script we want to start.</param>
            <param name="mode">Stop mode of type kvSCRIPT_STOP_xx.</param>
            <returns>KvStatus.OK if success else canStatus.canERR_XXX.</returns>
        </member>
        <member name="M:Kvaser.CanLib.Canlib.kvScriptTxeGetData(System.String,System.Int32,System.Object@)">
            <summary>
            This function can be used to retrieve information from a compiled script file (.txe).
            </summary>
            <param name="filePathOnPC">Path to the script file on PC.</param>
            <param name="item">Item to obtain. Valid values are one of the constants canTXEDATA_xxx..</param>
            <param name="buffer">Return value as object.</param>
            <returns>KvStatus.OK if success else KvStatus.ERR_XXX.</returns>
        </member>
        <member name="M:Kvaser.CanLib.Canlib.kvScriptUnload(System.Int32,System.Int32)">
            <summary>
             Unloads a stopped script.
            </summary>
            <param name="hnd">An open handle to a CAN channel.</param>
            <param name="slotNo">The slot where to load the script.</param>
            <returns>KvStatus.OK if success else KvStatus.ERR_XXX.</returns>
        </member>
        <member name="M:Kvaser.CanLib.Canlib.kvScriptEnvvarClose(System.Int64)">
            <summary>
             Close an open envvar.
            <para>&#160;</para>
            Note. Not implemented in linux.
            </summary>
            <param name="eHnd">An open handle to an envvar.</param>
            <returns>KvStatus.OK if success else KvStatus.ERR_XXX.</returns>
        </member>
        <member name="M:Kvaser.CanLib.Canlib.kvScriptEnvvarOpen(System.Int32,System.String,System.Int32@,System.Int32@)">
            <summary>
             Opens an existing envvar and returns a handle to it.
            <para>&#160;</para>
            Note. Not implemented in linux.
            </summary>
            <param name="hnd">An open handle to a CAN channel.</param>
            <param name="envvarName">The envvar's name; a pointer to a \c NULL terminated array of chars.</param>
            <param name="envvarType">A pointer to a 32-bit integer that will receive the kvENVVAR_TYPE_xxx type.</param>
            <param name="envvarSize">A pointer to a 32-bit integer that will receive the size of the envvar in bytes.</param>
            <returns>A KvHandle handle (positive) to an envvar if success, canERR_xxx (negative) if failure</returns>
        </member>
        <member name="M:Kvaser.CanLib.Canlib.kvScriptEnvvarGetData(System.Int64,System.Byte[]@,System.Int32,System.Int32)">
            <summary>
            Get a range of data bytes from an envvar.
            <para>&#160;</para>
            Note. Not implemented in linux.
            </summary>
            <param name="eHnd">An open handle to an envvar.</param>
            <param name="buf">A pointer to a data area where the retrieved data range should be stored.</param>
            <param name="start_index">The start index of the data range.</param>
            <param name="data_len">The length in bytes of the data range.</param>
            <returns>KvStatus.OK if success else KvStatus.ERR_XXX.</returns>
        </member>
        <member name="M:Kvaser.CanLib.Canlib.kvScriptEnvvarGetFloat(System.Int64,System.Single@)">
            <summary>
            Get the value of a float envvar.
            <para>&#160;</para>
            Note. Not implemented in linux.
            </summary>
            <param name="eHnd">An open handle to an envvar.</param>
            <param name="val">The current value.</param>
            <returns>KvStatus.OK if success else KvStatus.ERR_XXX.</returns>
        </member>
        <member name="M:Kvaser.CanLib.Canlib.kvScriptEnvvarGetInt(System.Int64,System.Int32@)">
            <summary>
            Get the value of an int envvar.
            <para>&#160;</para>
            Note. Not implemented in linux.
            </summary>
            <param name="eHnd">An open handle to an envvar.</param>
            <param name="val">The current value.</param>
            <returns>KvStatus.OK if success else KvStatus.ERR_XXX.</returns>
        </member>
        <member name="M:Kvaser.CanLib.Canlib.kvScriptGetText(System.Int32,System.Int32@,System.Int64@,System.Int32@,System.String@)">
             <summary>
            Reads a printf from a subscribed script slot. Set up a subscription with <see cref="M:Kvaser.CanLib.Canlib.kvScriptRequestText(System.Int32,System.Int32,System.Int32)"/>.
             </summary>
             <param name="hnd">An open handle to a CAN channel.</param>
             <param name="slot">The slot where the printf originated.</param>
             <param name="time">The printf timestamp.</param>
             <param name="flags">Printf flags. A combination of canSTAT_xxx flags.</param>
             <param name="buf">The printf string.</param>
             <returns>KvStatus.OK if success else KvStatus.ERR_XXX.</returns>
        </member>
        <member name="M:Kvaser.CanLib.Canlib.kvScriptEnvvarSetData(System.Int64,System.Byte[],System.Int32,System.Int32)">
            <summary>
            Set a range of data bytes in an envvar.
            <para>&#160;</para>
            Note. Not implemented in linux.
            </summary>
            <param name="eHnd">An open handle to an envvar.</param>
            <param name="buf">A pointer to a data area where the retrieved data range should be stored.</param>
            <param name="start_index">The start index of the data range.</param>
            <param name="data_len">The length in bytes of the data range.</param>
            <returns>KvStatus.OK if success else KvStatus.ERR_XXX.</returns>
        </member>
        <member name="M:Kvaser.CanLib.Canlib.kvScriptEnvvarSetFloat(System.Int64,System.Single)">
            <summary>
             Sets the value of a float envvar.
            <para>&#160;</para>
            Note. Not implemented in linux.
            </summary>
            <param name="eHnd">An open handle to an envvar.</param>
            <param name="val">The new value.</param>
            <returns>KvStatus.OK if success else KvStatus.ERR_XXX.</returns>
        </member>
        <member name="M:Kvaser.CanLib.Canlib.kvScriptEnvvarSetInt(System.Int64,System.Int32)">
            <summary>
             Sets the value of an int envvar.
            <para>&#160;</para>
            Note. Not implemented in linux.
            </summary>
            <param name="eHnd">An open handle to an envvar.</param>
            <param name="val">The new value.</param>
            <returns>KvStatus.OK if success else KvStatus.ERR_XXX.</returns>
        </member>
        <member name="M:Kvaser.CanLib.Canlib.kvScriptRequestText(System.Int32,System.Int32,System.Int32)">
            <summary>
            Sets up a printf subscription to a selected script slot. Read the printf messages with <see cref="M:Kvaser.CanLib.Canlib.kvScriptGetText(System.Int32,System.Int32@,System.Int64@,System.Int32@,System.String@)"/>.
            </summary>
            <param name="hnd">An open handle to a CAN channel.</param>
            <param name="slot">The slot to subscribe to.</param>
            <param name="request">Subscription request i.e. kvSCRIPT_REQUEST_TEXT_xxx.</param>
            <returns>KvStatus.OK if success else KvStatus.ERR_XXX.</returns>
        </member>
        <member name="M:Kvaser.CanLib.Canlib.kvScriptGetMaxEnvvarSize(System.Int32,System.Int32@)">
            <summary>
            Get the maximum size of an envvar.
            <para>&#160;</para>
            </summary>
            <param name="hnd">An open handle to a CAN channel.</param>
            <param name="size">The maximum size of an envvar.</param>
            <returns>KvStatus.OK if success else KvStatus.ERR_XXX.</returns>
        </member>
        <member name="M:Kvaser.CanLib.Canlib.kvSelfTest(System.Int32,System.Int32@)">
            <summary>
            Runs a built-in self test in the device. Note that not all devices supports built-in self tests.
            </summary>
            <param name="hnd">An open handle to a CAN channel.</param>
            <param name="presults">Self test result</param>
            <returns>KvStatus.OK if success else KvStatus.ERR_XXX.</returns>
        </member>
        <member name="M:Kvaser.CanLib.Canlib.kvSetNotifyCallback(System.Int32,Kvaser.CanLib.Canlib.kvCallbackDelegate,System.IntPtr,System.Int32)">
            <summary>
            The function registers a callback function which is called when certain events occur.
            You can register at most one callback function per handle at any time.
            To remove the callback, call <see cref="M:Kvaser.CanLib.Canlib.kvSetNotifyCallback(System.Int32,Kvaser.CanLib.Canlib.kvCallbackDelegate,System.IntPtr,System.Int32)"/> with a NULL pointer in the callback argument.
            <para>&#160;</para>
            Note. The callback function is called in the context of a high-priority thread created by CANlib.
            You should take precaution not to do any time consuming tasks in the callback. You must also arrange the synchronization between the callback and your other threads yourself.
            </summary>
            <param name="handle">An open handle to a CAN channel.</param>
            <param name="callback">A pointer to a callback function of type <see cref="T:Kvaser.CanLib.Canlib.kvCallbackDelegate"/></param>
            <param name="context">A pointer to arbitrary user-defined context data which is passed to the callback function. </param>
            <param name="notifyFlags">One or more of the canNOTIFY_xxx flags.</param>
            <returns>KvStatus.OK if success else KvStatus.ERR_XXX.</returns>
        </member>
        <member name="M:Kvaser.CanLib.Canlib.kvTimeDomainAddHandle(System.Object,System.Int32)">
            <summary>
            This routine adds an open channel handle to a domain.
            <para>&#160;</para>
            Note. A time domain is a set of channels with a common time base.
            </summary>
            <param name="domain">A TimeDomain returned from <see cref="M:Kvaser.CanLib.Canlib.kvTimeDomainCreate(System.Object@)"/></param>
            <param name="handle">A Handle to an open channel</param>
            <returns>KvStatus.OK if success else KvStatus.ERR_XXX.</returns>
        </member>
        <member name="M:Kvaser.CanLib.Canlib.kvTimeDomainCreate(System.Object@)">
            <summary>
            This routine creates an empty time domain.
            The variable is set by this function and then used in later calls to other functions using a <see cref="T:System.IntPtr"/>.
            Time domains created by <see cref="M:Kvaser.CanLib.Canlib.kvTimeDomainCreate(System.Object@)"/> can be destroyed with a call to <see cref="M:Kvaser.CanLib.Canlib.kvTimeDomainDelete(System.Object)"/>.
            <para>&#160;</para>
            Note. A time domain is a set of channels with a common time base.
            </summary>
            <param name="domain">An empty TimeDomain object</param>
            <returns>KvStatus.OK if success else KvStatus.ERR_XXX.</returns>
        </member>
        <member name="M:Kvaser.CanLib.Canlib.kvTimeDomainDelete(System.Object)">
            <summary>
            This is a cleanup routine that deletes all members of a domain and then deletes the domain itself.
            <para>&#160;</para>
            Note. A time domain is a set of channels with a common time base.
            </summary>
            <param name="domain">A TimeDomain returned from <see cref="M:Kvaser.CanLib.Canlib.kvTimeDomainCreate(System.Object@)"/></param>
            <returns>KvStatus.OK if success else KvStatus.ERR_XXX.</returns>
        </member>
        <member name="M:Kvaser.CanLib.Canlib.kvTimeDomainGetData(System.Object,Kvaser.CanLib.Canlib.kvTimeDomainData@)">
            <summary>
            This routine collects some data on a time domain.
            </summary>
            <remarks>A time domain is a set of channels with a common time base.</remarks>
            <param name="domain">A TimeDomain returned from <see cref="M:Kvaser.CanLib.Canlib.kvTimeDomainCreate(System.Object@)"/></param>
            <param name="data"> A <see cref="T:Kvaser.CanLib.Canlib.kvTimeDomainData"/> structure that is filled by the function</param>
            <returns>KvStatus.OK if success else KvStatus.ERR_XXX.</returns>
        </member>
        <member name="M:Kvaser.CanLib.Canlib.kvTimeDomainRemoveHandle(System.Object,System.Int32)">
            <summary>
            This routine removes an open channel handle from a domain.
            <para>&#160;</para>
            Note. A time domain is a set of channels with a common time base.
            </summary>
            <param name="domain">A TimeDomain returned from <see cref="M:Kvaser.CanLib.Canlib.kvTimeDomainCreate(System.Object@)"/></param>
            <param name="handle">A Handle to an open channel</param>
            <returns>KvStatus.OK if success else KvStatus.ERR_XXX.</returns>
        </member>
        <member name="M:Kvaser.CanLib.Canlib.kvTimeDomainResetTime(System.Object)">
            <summary>
            This routine resets the time on all members of a time domain.
            After a call to this routine timestamps from all channels with MagiSync running have no offset at all any longer.
            The same applies for channels that reside on the same physical interface.
            <para>&#160;</para>
            Note. A time domain is a set of channels with a common time base.
            </summary>
            <param name="domain">A TimeDomain returned from <see cref="M:Kvaser.CanLib.Canlib.kvTimeDomainCreate(System.Object@)"/></param>
            <returns>KvStatus.OK if success else KvStatus.ERR_XXX.</returns>
        </member>
        <member name="T:Kvaser.CanLib.Canlib.kvCallbackDelegate">
            <summary>
            Callback for Notifications, used in <see cref="M:Kvaser.CanLib.Canlib.kvSetNotifyCallback(System.Int32,Kvaser.CanLib.Canlib.kvCallbackDelegate,System.IntPtr,System.Int32)"/>
            The callback function is called with the following arguments:<para>&#160;</para>
            handle - the handle of the CAN channel where the event happened.<para>&#160;</para>
            context - the context pointer you passed to <see cref="M:Kvaser.CanLib.Canlib.kvSetNotifyCallback(System.Int32,Kvaser.CanLib.Canlib.kvCallbackDelegate,System.IntPtr,System.Int32)"/>.<para>&#160;</para>
            notifyEvent - one of the canNOTIFY_xxx notification codes.<para>&#160;</para>
            </summary>
        </member>
        <member name="T:Kvaser.CanLib.Canlib.canStatus">
            <summary>
                Generally, a return code greater than or equal to zero means success. A value less than zero means failure.
            </summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canStatus.canOK">
            <summary>Normal successful completion; The driver is just fine, and really believes it carried out your command to everyone's satisfaction. </summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canStatus.canERR_PARAM">
            <summary>Error in one or more parameters; a parameter specified in the call was invalid, out of range, or so. This status code will also be returned when the call is not implemented. </summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canStatus.canERR_NOMSG">
            <summary>There were no messages to read; A function tried to read a message, but there was no message to read. </summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canStatus.canERR_NOTFOUND">
            <summary>Specified device or channel not found. There is no hardware available that matches the given search criteria.
            For example, you may have specified canOPEN_REQUIRE_EXTENDED but there's no controller capable of extended CAN.
            You may have specified a channel number that is out of the range for the hardware in question. You may have requested exclusive
            access to a channel, but the channel is already occupied. </summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canStatus.canERR_NOMEM">
            <summary>Out of memory; A memory allocation failed. </summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canStatus.canERR_NOCHANNELS">
            <summary>No channels available; There is indeed hardware matching the criteria you specified, but there are no channels available,
            or the channel you specified is already occupied. </summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canStatus.canERR_INTERRUPTED">
            <summary>Interrupted by signals.</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canStatus.canERR_TIMEOUT">
            <summary>Timeout occurred; A function waited for something to happen (for example, the arrival of a message), but that something didn't happen. </summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canStatus.canERR_NOTINITIALIZED">
            <summary>The library is not initialized; The driver is not initialized. canInitializeLibrary() was probably not called? </summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canStatus.canERR_NOHANDLES">
            <summary>Out of handles; No handles are available inside canlib32. The application has too many handles open (i.e. has called canOpenChannel() too many times, or there's a memory leak somewhere.)<para>&#160;</para>
             Note. We are not talking about Windows handles here, it's CANLIB's own internal handles. </summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canStatus.canERR_INVHANDLE">
            <summary>Handle is invalid; The CANLIB handle you specified (if the API call includes a handle) is not valid. Ensure you are passing the handle and not, for example, a channel number. </summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canStatus.canERR_INIFILE">
            <summary>Error in the ini-file (16-bit only) </summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canStatus.canERR_DRIVER">
            <summary>Driver type not supported; CAN driver mode is not supported by the present hardware. </summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canStatus.canERR_TXBUFOFL">
            <summary>Transmit buffer overflow; The transmit queue was full, so the message was dropped. </summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canStatus.canERR_RESERVED_1">
            <summary>Reserved.</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canStatus.canERR_HARDWARE">
            <summary>A hardware error has occurred; Something probably related to the hardware happened. This could mean that the device does not respond (IRQ or address conflict?),
            or that the response was invalid or unexpected (faulty card?). </summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canStatus.canERR_DYNALOAD">
            <summary>A driver DLL can't be found or loaded; (One of) the DLL(s) specified in the registry failed to load. This could be a driver installation problem. </summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canStatus.canERR_DYNALIB">
            <summary>A DLL seems to have wrong version; DLL version mismatch. (One of) the DLL(s) specified in the registry is - probably - too old, or - less likely - too new. </summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canStatus.canERR_DYNAINIT">
            <summary>Error when initializing a DLL; Something failed when a device driver was being initialized. In other words, we can open the driver but it makes a lot of fuss about something we don't understand. </summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canStatus.canERR_NOT_SUPPORTED">
            <summary>Operation not supported by hardware or firmware. </summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canStatus.canERR_RESERVED_5">
            <summary>Reserved.</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canStatus.canERR_RESERVED_6">
            <summary>Reserved.</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canStatus.canERR_RESERVED_2">
            <summary>Reserved.</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canStatus.canERR_DRIVERLOAD">
            <summary>Can't find or load kernel driver; A device driver (kernel mode driver for NT, VxD for W95/98) failed to load; or the DLL could not open the device. Privileges? Driver file missing?</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canStatus.canERR_DRIVERFAILED">
            <summary>DeviceIOControl failed; Use Win32 GetLastError() to learn what really happened. </summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canStatus.canERR_NOCONFIGMGR">
            <summary>Can't find req'd config s/w (e.g. CS/SS) </summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canStatus.canERR_NOCARD">
            <summary>The card was removed or not inserted. </summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canStatus.canERR_RESERVED_7">
            <summary>Reserved.</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canStatus.canERR_REGISTRY">
            <summary>Error (missing data) in the Registry; A registry key is missing, invalid, malformed, has gone for lunch or what not. can_verify.exe might provide some insight. </summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canStatus.canERR_LICENSE">
            <summary>The license is not valid. </summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canStatus.canERR_INTERNAL">
            <summary>Internal error in the driver; Indicates an error condition in the driver or DLL, which couldn't be properly handled. Please contact the friendly support at support@kvaser.com. </summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canStatus.canERR_NO_ACCESS">
            <summary>Access denied; This means that you tried to set the bit rate on a handle to which you haven't got init access or you tried to open a channel that already is open with init access. See canOpenChannel() for more information about init access. </summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canStatus.canERR_NOT_IMPLEMENTED">
            <summary>Not implemented; The requested feature or function is not implemented in the device you are trying to use it on. </summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canStatus.canERR_DEVICE_FILE">
            <summary>Device File error; An error has occured when trying to access a file on the device. </summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canStatus.canERR_HOST_FILE">
            <summary>Host File error; An error has occured when trying to access a file on the host. </summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canStatus.canERR_DISK">
            <summary>Disk error; A disk error has occurred. Verify that the disk is initialized. </summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canStatus.canERR_CRC">
            <summary>CRC error; The CRC calculation did not match the expected result. </summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canStatus.canERR_CONFIG">
            <summary>Configuration Error; The configuration is corrupt. </summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canStatus.canERR_MEMO_FAIL">
            <summary>Memo Error; Other configuration error. </summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canStatus.canERR_SCRIPT_FAIL">
             <summary>Script Fail; A script has failed.
            Note. This code represents several different failures, for example:<para>&#160;</para>
            Trying to load a corrupt file or not a .txe file<para>&#160;</para>
            Trying to start a t script that has not been loaded<para>&#160;</para>
            Trying to load a t script compiled with the wrong version of the t compiler<para>&#160;</para>
            Trying to unload a t script that has not been stopped<para>&#160;</para>
            Trying to use an envvar that does not exist
            </summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canStatus.canERR_SCRIPT_WRONG_VERSION">
            <summary>The t script version dosen't match the version(s) that the device firmware supports.; </summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canStatus.canERR_SCRIPT_TXE_CONTAINER_VERSION">
            <summary>The compiled t script container file format is of a version which is not supported by this version of canlib.; </summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canStatus.canERR_SCRIPT_TXE_CONTAINER_FORMAT">
            <summary>An error occured while trying to parse the compiled t script file.; </summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canStatus.canERR_BUFFER_TOO_SMALL">
            <summary>The buffer provided was not large enough to contain the requested data.; </summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canStatus.canERR_IO_WRONG_PIN_TYPE">
            <summary>
            The I/O pin doesn't exist or the I/O pin type doesn't match the called function,
            e.g. trying to use input pins as outputs or use digital pins as analog pins.
            </summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canStatus.canERR_IO_NOT_CONFIRMED">
            <summary>
            The I/O pin configuration is not confirmed. Use kvIoConfirmConfig()
            to confirm the configuration.
            </summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canStatus.canERR_IO_CONFIG_CHANGED">
            <summary>
            The I/O pin configuration has changed after last call to kvIoConfirmConfig. Use kvIoConfirmConfig()
            to confirm the new configuration.
            </summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canStatus.canERR_IO_PENDING">
            <summary>
            The previous I/O pin value has not yet changed the output and is still pending.
            This happens when e.g. kvIoPinSetAnalog() is called twice on the same pin within a short time.
            </summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canStatus.canERR_IO_NO_VALID_CONFIG">
            <summary>There is no valid I/O pin configuration.</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canStatus.canERR__RESERVED">
            <summary>Reserved.</summary>
        </member>
        <member name="T:Kvaser.CanLib.Canlib.kvIOGetInfo">
            <summary> These defines are used to choose item in <see cref="M:Kvaser.CanLib.Canlib.kvIoPinGetInfo(System.Int32,System.Int32,Kvaser.CanLib.Canlib.kvIOGetInfo,System.Object@)"/>. </summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.kvIOGetInfo.MODULE_TYPE">
            <summary>An unsigned 32-bit integer, <see cref="F:Kvaser.CanLib.Canlib.kvIOGetInfo.MODULE_TYPE"/>. Read-only. </summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.kvIOGetInfo.DIRECTION">
            <summary>An unsigned 32-bit integer, <see cref="F:Kvaser.CanLib.Canlib.kvIOGetInfo.DIRECTION"/>. Read-only. </summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.kvIOGetInfo.PIN_TYPE">
            <summary>An unsigned 32-bit integer, <see cref="F:Kvaser.CanLib.Canlib.kvIOGetInfo.PIN_TYPE"/>. Read-only.</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.kvIOGetInfo.NUMBER_OF_BITS">
            <summary>An unsigned 32-bit integer that contains the resolution in number of bits. Read-only. </summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.kvIOGetInfo.RANGE_MIN">
            <summary>A float that contains the lower range limit in volts. Read-only. Note. This is not applicable for relay pins. </summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.kvIOGetInfo.RANGE_MAX">
            <summary>A float that contains the upper range limit in volts. Read-only. Note. This is not applicable for relay pins.</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.kvIOGetInfo.DI_LOW_HIGH_FILTER">
            <summary>An unsigned 32-bit integer that contains the filter time in micro seconds when a digital input pin goes from LOW to HIGH.</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.kvIOGetInfo.DI_HIGH_LOW_FILTER">
            <summary>An unsigned 32-bit integer that contains the filter time in micro seconds when a digital input pin goes from HIGH to LOW.</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.kvIOGetInfo.AI_LP_FILTER_ORDER">
            <summary>An unsigned 32-bit integer that contains the low-pass filter order for an analog input pin.</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.kvIOGetInfo.AI_HYSTERESIS">
            <summary>A float that contains the hysteresis in volt for an analog input pin, i.e. the amount the input have to change before the sampled value is updated.</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.kvIOGetInfo.MODULE_NUMBER">
            <summary>An unsigned 32-bit integer that contains the module number the pin belongs to. The number starts from 0. Read-only. </summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.kvIOGetInfo.SERIAL_NUMBER">
            <summary>An unsigned 32-bit integer that contains the serial number of the submodule the pin belongs to. Read-only. </summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.kvIOGetInfo.FW_VERSION">
            <summary>An unsigned 32-bit integer that contains the software version number of the submodule the pin belongs to.
            This number consists of two 16-bit words, where the most significant word represents the major and the least significant the minor software version number. Read-only.</summary>
        </member>
        <member name="T:Kvaser.CanLib.Canlib.kvIOModuleType">
            <summary>One of these constants is returned when requesting <see cref="F:Kvaser.CanLib.Canlib.kvIOGetInfo.MODULE_TYPE"/> using <see cref="M:Kvaser.CanLib.Canlib.kvIoPinGetInfo(System.Int32,System.Int32,Kvaser.CanLib.Canlib.kvIOGetInfo,System.Object@)"/>.</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.kvIOModuleType.DIGITAL">
            <summary>Kvaser Add-on module with digital inputs and digital outputs.</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.kvIOModuleType.ANALOG">
            <summary>Kvaser Add-on module with analog inputs and analog outputs.</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.kvIOModuleType.RELAY">
            <summary>Kvaser Add-on module with relays and digital inputs.</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.kvIOModuleType.INTERNAL">
            <summary>Kvaser built-in module with one digital input and one digital output.</summary>
        </member>
        <member name="T:Kvaser.CanLib.Canlib.kvIOPinType">
            <summary> These defines are result when requesting <see cref="F:Kvaser.CanLib.Canlib.kvIOGetInfo.PIN_TYPE"/>. </summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.kvIOPinType.DIGITAL">
            <summary>Digital</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.kvIOPinType.ANALOG">
            <summary>Analog</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.kvIOPinType.RELAY">
            <summary>Relay</summary>
        </member>
        <member name="T:Kvaser.CanLib.Canlib.kvIOSetInfo">
            <summary> These defines are used to choose item <see cref="M:Kvaser.CanLib.Canlib.kvIoPinSetInfo(System.Int32,System.Int32,Kvaser.CanLib.Canlib.kvIOSetInfo,System.Object)"/>.</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.kvIOSetInfo.DI_LOW_HIGH_FILTER">
            <summary>An unsigned 32-bit integer that contains the filter time in micro seconds when a digital input pin goes from LOW to HIGH.</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.kvIOSetInfo.DI_HIGH_LOW_FILTER">
            <summary>An unsigned 32-bit integer that contains the filter time in micro seconds when a digital input pin goes from HIGH to LOW.</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.kvIOSetInfo.AI_LP_FILTER_ORDER">
            <summary>An unsigned 32-bit integer that contains the low-pass filter order for an analog input pin.</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.kvIOSetInfo.AI_HYSTERESIS">
            <summary>A float that contains the hysteresis in volt for an analog input pin, i.e. the amount the input have to change before the sampled value is updated.</summary>
        </member>
        <member name="T:Kvaser.CanLib.Canlib.kvIOPinDirection">
            <summary> These defines are result when requesting <see cref="F:Kvaser.CanLib.Canlib.kvIOGetInfo.DIRECTION"/>. </summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.kvIOPinDirection.DIRECTION_IN">
            <summary>Input  </summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.kvIOPinDirection.DIRECTION_OUT">
            <summary>Output </summary>
        </member>
        <member name="T:Kvaser.CanLib.Canlib.canBusStatistics">
            <summary>This struct is returned by canGetBusStatistics(). The values are cleared when the corresponding channel goes on bus.</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canBusStatistics.stdData">
            <summary>Number of received standard (11-bit identifiers) data frames.</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canBusStatistics.stdRemote">
            <summary>Number of received standard (11-bit identifiers) remote frames.</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canBusStatistics.extData">
            <summary>Number of received extended (29-bit identifiers) data frames.</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canBusStatistics.extRemote">
            <summary>Number of received extended (29-bit identifiers) remote frames.</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canBusStatistics.errFrame">
            <summary>Number of error frames.</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canBusStatistics.busLoad">
            <summary>Bus load</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canBusStatistics.overruns">
            <summary>The number of overruns detected by the hardware, firmware or driver.</summary>
        </member>
        <member name="T:Kvaser.CanLib.Canlib.canUserIoPortData">
            <summary>canUserIoPortData  Used in <see cref="F:Kvaser.CanLib.Canlib.canIOCTL_SET_USER_IOPORT"/> and <see cref="F:Kvaser.CanLib.Canlib.canIOCTL_GET_USER_IOPORT"/>.</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canUserIoPortData.portNo">
            <summary>Port number used in e.g. <see cref="F:Kvaser.CanLib.Canlib.canIOCTL_SET_USER_IOPORT"/> /<see cref="F:Kvaser.CanLib.Canlib.canIOCTL_GET_USER_IOPORT"/>.</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canUserIoPortData.portValue">
            <summary>Port value used in e.g. <see cref="F:Kvaser.CanLib.Canlib.canIOCTL_SET_USER_IOPORT"/> /<see cref="F:Kvaser.CanLib.Canlib.canIOCTL_GET_USER_IOPORT"/>.</summary>
        </member>
        <member name="T:Kvaser.CanLib.Canlib.kvTimeDomainData">
            <summary>Used for time domain handling.</summary>
        </member>
        <member name="P:Kvaser.CanLib.Canlib.kvTimeDomainData.nMagiSyncGroups">
            <summary>number of MagiSync groups.</summary>
        </member>
        <member name="P:Kvaser.CanLib.Canlib.kvTimeDomainData.nMagiSyncedMembers">
            <summary>number of MagiSync members.</summary>
        </member>
        <member name="P:Kvaser.CanLib.Canlib.kvTimeDomainData.nNonMagiSyncCards">
            <summary>number of non MagiSync interfaces.</summary>
        </member>
        <member name="P:Kvaser.CanLib.Canlib.kvTimeDomainData.nNonMagiSyncedMembers">
            <summary>number of non MagiSync members.</summary>
        </member>
        <member name="T:Kvaser.CanLib.Canlib.canChannelDataVersion">
            <summary>Version info
            Used in <see cref="M:Kvaser.CanLib.Canlib.canIoCtl(System.Int32,System.Int32,System.Object@)"/> when requesting <see cref="F:Kvaser.CanLib.Canlib.canCHANNELDATA_DLL_FILE_VERSION"/>,
            <see cref="F:Kvaser.CanLib.Canlib.canCHANNELDATA_DLL_PRODUCT_VERSION"/>, <see cref="F:Kvaser.CanLib.Canlib.canCHANNELDATA_DRIVER_FILE_VERSION"/> or
            <see cref="F:Kvaser.CanLib.Canlib.canCHANNELDATA_DRIVER_PRODUCT_VERSION"/></summary>
        </member>
        <member name="P:Kvaser.CanLib.Canlib.canChannelDataVersion.Version1">
            <summary>Version1</summary>
        </member>
        <member name="P:Kvaser.CanLib.Canlib.canChannelDataVersion.Version2">
            <summary>Version2</summary>
        </member>
        <member name="P:Kvaser.CanLib.Canlib.canChannelDataVersion.Version3">
            <summary>Version3</summary>
        </member>
        <member name="P:Kvaser.CanLib.Canlib.canChannelDataVersion.Version4">
            <summary>Version4</summary>
        </member>
        <member name="M:Kvaser.CanLib.Canlib.canChannelDataVersion.op_Implicit(Kvaser.CanLib.Canlib.canChannelDataVersion)~System.Int32[]">
            <summary>Conversion operator returning Int32[] buffer</summary>
        </member>
        <member name="T:Kvaser.CanLib.Canlib.canChannelDataHwStatus">
            <summary>HW Status.
            Used in <see cref="M:Kvaser.CanLib.Canlib.canIoCtl(System.Int32,System.Int32,System.Object@)"/> when requesting <see cref="F:Kvaser.CanLib.Canlib.canCHANNELDATA_LOGGER_TYPE"/></summary>
        </member>
        <member name="P:Kvaser.CanLib.Canlib.canChannelDataHwStatus.HwStatus1">
            <summary>HW Status1</summary>
        </member>
        <member name="P:Kvaser.CanLib.Canlib.canChannelDataHwStatus.HwStatus2">
            <summary>HW Status2</summary>
        </member>
        <member name="P:Kvaser.CanLib.Canlib.canChannelDataHwStatus.HwStatus3">
            <summary>HW Status3</summary>
        </member>
        <member name="P:Kvaser.CanLib.Canlib.canChannelDataHwStatus.HwStatus4">
            <summary>HW Status4</summary>
        </member>
        <member name="P:Kvaser.CanLib.Canlib.canChannelDataHwStatus.HwStatus5">
            <summary>HW Status5</summary>
        </member>
        <member name="P:Kvaser.CanLib.Canlib.canChannelDataHwStatus.HwStatus6">
            <summary>HW Status6</summary>
        </member>
        <member name="M:Kvaser.CanLib.Canlib.canChannelDataHwStatus.op_Implicit(Kvaser.CanLib.Canlib.canChannelDataHwStatus)~System.Int32[]">
            <summary>Conversion operator returning Int32[] buffer</summary>
        </member>
        <member name="T:Kvaser.CanLib.Canlib.kvClockInfo">
            <summary>Returned when using <see cref="F:Kvaser.CanLib.Canlib.canCHANNELDATA_CLOCK_INFO"/>
            Returns clock characteristics for device
            The device clock frequency can then be calculated as:
            double frequency = numerator/denominator * 10 ** power_of_ten;</summary>
        </member>
        <member name="P:Kvaser.CanLib.Canlib.kvClockInfo.version">
            <summary>The version of this struct, currently 1</summary>
        </member>
        <member name="P:Kvaser.CanLib.Canlib.kvClockInfo.numerator">
            <summary>The numerator part of the device clock frequency.</summary>
        </member>
        <member name="P:Kvaser.CanLib.Canlib.kvClockInfo.denominator">
            <summary>The denominator part of the device clock frequency.</summary>
        </member>
        <member name="P:Kvaser.CanLib.Canlib.kvClockInfo.power_of_ten">
            <summary>The power_of_ten part of the device clock frequency.</summary>
        </member>
        <member name="P:Kvaser.CanLib.Canlib.kvClockInfo.accuracy_ppm">
            <summary>The accuracy (in ppm) of the device clock.</summary>
        </member>
        <member name="T:Kvaser.CanLib.Canlib.kvBusParamLimits">
             <summary>Returned when using <see cref="F:Kvaser.CanLib.Canlib.canCHANNELDATA_BUS_PARAM_LIMITS"/>
             
             This struct shows the low level limits of the parameters.
                    
             The tq field is always zero for both min/max arbitration/data, and is reserved
             for possible other uses in future releases.
            
             If prop is zero for both min and max values, that means that the unit
             does not distinguish between phase segment one and the propagation
             segment, i.e. the limit applies to (phase1 + prop).
             </summary>
             <remarks>This is only intended for internal use.</remarks>
        </member>
        <member name="P:Kvaser.CanLib.Canlib.kvBusParamLimits.version">
            <summary>The version of this struct, currently 2</summary>
        </member>
        <member name="P:Kvaser.CanLib.Canlib.kvBusParamLimits.arbitration_min">
            <summary>Arbitration phase minimum parameters.</summary>
        </member>
        <member name="P:Kvaser.CanLib.Canlib.kvBusParamLimits.arbitration_max">
            <summary>Arbitration phase maximum parameters.</summary>
        </member>
        <member name="P:Kvaser.CanLib.Canlib.kvBusParamLimits.data_min">
            <summary>Data phase minimum parameters.</summary>
        </member>
        <member name="P:Kvaser.CanLib.Canlib.kvBusParamLimits.data_max">
            <summary>Data phase maximum parameters.</summary>
        </member>
        <member name="T:Kvaser.CanLib.Canlib.kvBusParamsTq">
            <summary>Returned when using <see cref="M:Kvaser.CanLib.Canlib.canGetBusParamsTq(System.Int32,Kvaser.CanLib.Canlib.kvBusParamsTq@)"/>, <see cref="M:Kvaser.CanLib.Canlib.canGetBusParamsFdTq(System.Int32,Kvaser.CanLib.Canlib.kvBusParamsTq@,Kvaser.CanLib.Canlib.kvBusParamsTq@)"/>
            This struct shows the low level limits of the parameters.
            Note that seg1 = prop + phase1 and seg2 = phase2</summary>
        </member>
        <member name="P:Kvaser.CanLib.Canlib.kvBusParamsTq.tq">
            <summary>Total bit time, in number of time quanta.</summary>
        </member>
        <member name="P:Kvaser.CanLib.Canlib.kvBusParamsTq.phase1">
            <summary>Phase segment 1, in number of time quanta</summary>
        </member>
        <member name="P:Kvaser.CanLib.Canlib.kvBusParamsTq.phase2">
            <summary>Phase segment 2, in number of time quanta</summary>
        </member>
        <member name="P:Kvaser.CanLib.Canlib.kvBusParamsTq.sjw">
            <summary>Sync jump width, in number of time quanta</summary>
        </member>
        <member name="P:Kvaser.CanLib.Canlib.kvBusParamsTq.prop">
            <summary>Propagation segment, in number of time quanta</summary>
        </member>
        <member name="P:Kvaser.CanLib.Canlib.kvBusParamsTq.prescaler">
            <summary>Prescaler</summary>
        </member>
        <member name="M:Kvaser.CanLib.Canlib.kvBusParamsTq.#ctor(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            constructor, setting all default values.
            </summary>
        </member>
        <member name="M:Kvaser.CanLib.Canlib.kvBusParamsTq.SetValues(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Function, setting all structure values.
            </summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canBITRATE_1M">
            <summary>Used in <see cref="M:Kvaser.CanLib.Canlib.canSetBusParams(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)"/> and <see cref="M:Kvaser.CanLib.Canlib.canSetBusParamsC200(System.Int32,System.Byte,System.Byte)"/>
            Indicate a bitrate of 1 Mbit/s. </summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canBITRATE_500K">
            <summary>Used in <see cref="M:Kvaser.CanLib.Canlib.canSetBusParams(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)"/> and <see cref="M:Kvaser.CanLib.Canlib.canSetBusParamsC200(System.Int32,System.Byte,System.Byte)"/>
            Indicate a bitrate of 500 kbit/s.  </summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canBITRATE_250K">
            <summary>Used in <see cref="M:Kvaser.CanLib.Canlib.canSetBusParams(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)"/> and <see cref="M:Kvaser.CanLib.Canlib.canSetBusParamsC200(System.Int32,System.Byte,System.Byte)"/>
            Indicate a bitrate of  250 kbit/s. </summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canBITRATE_125K">
            <summary>Used in <see cref="M:Kvaser.CanLib.Canlib.canSetBusParams(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)"/> and <see cref="M:Kvaser.CanLib.Canlib.canSetBusParamsC200(System.Int32,System.Byte,System.Byte)"/>
            Indicate a bitrate of 125 kbit/s. </summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canBITRATE_100K">
            <summary>Used in <see cref="M:Kvaser.CanLib.Canlib.canSetBusParams(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)"/> and <see cref="M:Kvaser.CanLib.Canlib.canSetBusParamsC200(System.Int32,System.Byte,System.Byte)"/>
            Indicate a bitrate of 100 kbit/s. </summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canBITRATE_62K">
            <summary>Used in <see cref="M:Kvaser.CanLib.Canlib.canSetBusParams(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)"/> and <see cref="M:Kvaser.CanLib.Canlib.canSetBusParamsC200(System.Int32,System.Byte,System.Byte)"/>
            Indicate a bitrate of 62 kbit/s.  </summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canBITRATE_50K">
            <summary>Used in <see cref="M:Kvaser.CanLib.Canlib.canSetBusParams(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)"/> and <see cref="M:Kvaser.CanLib.Canlib.canSetBusParamsC200(System.Int32,System.Byte,System.Byte)"/>
            Indicate a bitrate of 50 kbit/s. </summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canBITRATE_83K">
            <summary>Used in <see cref="M:Kvaser.CanLib.Canlib.canSetBusParams(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)"/> and <see cref="M:Kvaser.CanLib.Canlib.canSetBusParamsC200(System.Int32,System.Byte,System.Byte)"/>
            Indicate a bitrate of 83 kbit/s.  </summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canBITRATE_10K">
            <summary>Used in <see cref="M:Kvaser.CanLib.Canlib.canSetBusParams(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)"/> and <see cref="M:Kvaser.CanLib.Canlib.canSetBusParamsC200(System.Int32,System.Byte,System.Byte)"/>
            Indicate a bitrate of 10 kbit/s. </summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canFD_BITRATE_500K_80P">
            <summary>Used in <see cref="M:Kvaser.CanLib.Canlib.canSetBusParams(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)"/> and <see cref="M:Kvaser.CanLib.Canlib.canSetBusParamsFd(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)"/> when using the CAN FD protocol.
            Indicates a bitrate of 0.5 Mbit/s and sampling point at 80%. </summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canFD_BITRATE_1M_80P">
            <summary>Used in <see cref="M:Kvaser.CanLib.Canlib.canSetBusParams(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)"/> and <see cref="M:Kvaser.CanLib.Canlib.canSetBusParamsFd(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)"/> when using the CAN FD protocol.
            Indicates a bitrate of 1.0 Mbit/s and sampling point at 80%. </summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canFD_BITRATE_2M_80P">
            <summary>Used in <see cref="M:Kvaser.CanLib.Canlib.canSetBusParams(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)"/> and <see cref="M:Kvaser.CanLib.Canlib.canSetBusParamsFd(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)"/> when using the CAN FD protocol.
            Indicates a bitrate of 2.0 Mbit/s and sampling point at 80%. </summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canFD_BITRATE_4M_80P">
            <summary>Used in <see cref="M:Kvaser.CanLib.Canlib.canSetBusParams(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)"/> and <see cref="M:Kvaser.CanLib.Canlib.canSetBusParamsFd(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)"/> when using the CAN FD protocol.
            Indicates a bitrate of 4.0 Mbit/s and sampling point at 80%.</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canFD_BITRATE_8M_60P">
            <summary>Used in <see cref="M:Kvaser.CanLib.Canlib.canSetBusParams(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)"/> and <see cref="M:Kvaser.CanLib.Canlib.canSetBusParamsFd(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)"/> when using the CAN FD protocol.
            Indicates a bitrate of 8.0 Mbit/s and sampling point at 60%. </summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canFD_BITRATE_8M_80P">
            <summary>Used in <see cref="M:Kvaser.CanLib.Canlib.canSetBusParams(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)"/> and <see cref="M:Kvaser.CanLib.Canlib.canSetBusParamsFd(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)"/> when using the CAN FD protocol.
            Indicates a bitrate of 8.0 Mbit/s and sampling point at 80%. </summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canCHANNELDATA_CHANNEL_CAP">
            <summary>Buffer points to a 32-bit unsigned integer that receives the capabilities of the CAN controller;
            this is a combination of the canCHANNEL_CAP_xxx flags.</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canCHANNELDATA_TRANS_CAP">
            <summary>Buffer points to a 32-bit unsigned integer that receives the capabilities of the CAN transceiver;
            this is a combination of the canDRIVER_CAP_xxx flags.</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canCHANNELDATA_CHANNEL_FLAGS">
            <summary>Buffer points to a 32-bit unsigned integer that receives a combination of canCHANNEL_IS_xxx flags.</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canCHANNELDATA_CARD_TYPE">
            <summary>Buffer points to a 32-bit unsigned integer that receives the hardware type of the card.
            This value is any one of the canHWTYPE_xxx constants</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canCHANNELDATA_CARD_NUMBER">
            <summary>Buffer points to a 32-bit unsigned integer that receives the card's number in the computer.
            Each card type is numbered separately. For example, the first LAPcan card in a machine will have
            number 0, the second LAPcan number 1, etc.</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canCHANNELDATA_CHAN_NO_ON_CARD">
            <summary>Buffer points to a 32-bit unsigned integer which receives the channel number on the card.</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canCHANNELDATA_CARD_SERIAL_NO">
            <summary>Buffer points to a 64-bit (8 bytes) area which receives the serial number of the card.
            If the card doesn't have a serial number, 0 is returned. The serial number is an 8-byte unsigned
            integer. Currently, no products are using all 8 bytes; at most 4 bytes are used.</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canCHANNELDATA_TRANS_SERIAL_NO">
            <summary>Buffer points to a 64-bit (8 bytes) area which receives the serial number of the
            transceiver. The serial number is an 8-byte unsigned integer. If the transceiver doesn't have a
            serial number, 0 is returned.</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canCHANNELDATA_CARD_FIRMWARE_REV">
            <summary>Buffer points to a 64-bit (8 bytes) area which receives the firmware revision number
            on the card. This number consists of four 16-bit words: the major revision, the minor revision,
            the release number and the build number, listed in order from the most significant to the least
            significant.</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canCHANNELDATA_CARD_HARDWARE_REV">
            <summary>Buffer points to a 64-bit (8 bytes) area which receives the hardware revision number
            on the card. This number consists of four 16-bit words; the two most significant are always 0,
            and the two least significant are the major revision and the minor revision, listed in order
            from the most significant to the least significant.</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canCHANNELDATA_CARD_UPC_NO">
            <summary>Buffer points to a 64-bit (8 bytes) area which receives the UPC (EAN) number for the card.
            If there is no  UPC number, the buffer is filled with zeros.
            The UPC (EAN) number is coded as a BCD string, so e.g. 73-30130-00122-0 is coded as 0x0007330130001220.</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canCHANNELDATA_TRANS_UPC_NO">
            <summary>Buffer points to a 64-bit (8 bytes) area which receives the UPC (EAN) number for the transceiver.
            If there is no UPC number, the buffer is filled with zeros.
            The UPC (EAN) number is coded as a BCD string, so e.g. 73-30130-00122-0 is coded as 0x0007330130001220.
            Note. Not implemented in linux. </summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canCHANNELDATA_CHANNEL_NAME">
            <summary>Buffer points to an area which receives a zero-terminated string with a clear-text
            name of the channel.</summary>
            <remarks> Use of this item code is no longer recommended. The returned
            channel name doesn't contain the exact hardware type (it just contains
            the device family) and uses zero-based channel numbering, which is not
            user friendly.  Instead, use e.g. <see cref="F:Kvaser.CanLib.Canlib.canCHANNELDATA_DEVDESCR_ASCII"/> and
            <see cref="F:Kvaser.CanLib.Canlib.canCHANNELDATA_CHAN_NO_ON_CARD"/> to build your own channel name.</remarks>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canCHANNELDATA_DLL_FILE_VERSION">
             <summary>Buffer points to an array of 4 32-bit unsigned integers which receives the file
             version number of the second-level DLL driver file, i.e. the DLL that interfaces between
             canlib32.dll and the driver proper.<para>&#160;</para>
            0: 0<para>&#160;</para>
            1: The build number<para>&#160;</para>
            2: The minor revision number<para>&#160;</para>
            3: The major revision number<para>&#160;</para>
             </summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canCHANNELDATA_DLL_PRODUCT_VERSION">
             <summary>Buffer points to an array of four 32-bit integers which receives the file
             version number product version number of the second-level DLL driver file, i.e.
             the DLL that interfaces between canlib32.dll and the driver proper.
             Contents depending on index:<para>&#160;</para>
            0: 0<para>&#160;</para>
            1: 1<para>&#160;</para>
            2: The minor revision number<para>&#160;</para>
            3: The major revision number<para>&#160;</para>
            </summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canCHANNELDATA_DLL_FILETYPE">
             <summary>Buffer points to a 32-bit unsigned integer which receives a number that identifies
             the second-level DLL driver file, i.e. the DLL that interfaces between canlib32.dll and the
             driver proper.
            1: kvalapw.dll - used with CANlib up to 2.29.<para>&#160;</para>
            2: kvalapw2.dll - used with CANlib from 3.0 and on.<para>&#160;</para>
             </summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canCHANNELDATA_TRANS_TYPE">
            <summary>Buffer points to a 32-bit unsigned integer which receives the CAN transceiver type
            of the specified channel. This value is one of the canTRANSCEIVER_TYPE_xxx</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canCHANNELDATA_DEVICE_PHYSICAL_POSITION">
             <summary>Buffer points to a 32-bit unsigned integer which receives an address indicating where
             the device is located on its underlying bus. The interpretation of this number is bus-specific.
             If the address is unknown or the bus driver does not support an address, the bus driver leaves
             this member at its default value of 0xFFFFFFFF.
             The following list describes the information certain bus drivers store in the Address field for their child devices: <para>&#160;</para>
            ISA: Does not supply an address.Defaults to 0xFFFFFFFF.<para>&#160;</para>
            PC Card(PCMCIA): The socket number(typically 0x00 or 0x40)<para>&#160;</para>
            PCI: The device number in the high word and the function number in the low word.<para>&#160;</para>
            USB: The port number.<para>&#160;</para>
            Note. Not implemented in linux.
            </summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canCHANNELDATA_UI_NUMBER">
            <summary>Buffer points to a 32-bit unsigned integer which receives a number associated with the
            device that can be displayed in the user interface. This number is typically a user-perceived
            slot number, such as a number printed next to the slot on the board, or some other number that
            makes locating the physical device easier for the user. For buses with no such convention, or
            when the UI number is unknown, 0xFFFFFFFF is returned.</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canCHANNELDATA_TIMESYNC_ENABLED">
            <summary>Buffer points to a 32-bit unsigned integer which is set to 0, if the legacy time
            synchronization is not currently enabled for the specified channel, and 1, if the legacy time
            synchronization is currently enabled for the specified channel.</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canCHANNELDATA_DRIVER_FILE_VERSION">
             <summary>Buffer points to an array of four 32-bit integers which receives the file
             version number of the kernel-mode driver.
             Contents depending on index:<para>&#160;</para>
            0: The build number <para>&#160;</para>
            1: 0<para>&#160;</para>
            2: The minor revision number<para>&#160;</para>
            3: The major revision number<para>&#160;</para>
            </summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canCHANNELDATA_DRIVER_PRODUCT_VERSION">
             <summary>Buffer points to an array of four 32-bit integers which receives the product
             version number of the kernel-mode driver.
             Contents depending on index:<para>&#160;</para>
            0: 0<para>&#160;</para>
            1: 0<para>&#160;</para>
            2: The minor revision number<para>&#160;</para>
            3: The major revision number<para>&#160;</para>
            </summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canCHANNELDATA_MFGNAME_UNICODE">
            <summary>Buffer points to a string with the device manufacturer's name.
            Note. Not implemented in linux.</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canCHANNELDATA_MFGNAME_ASCII">
            <summary>Buffer points to a string with the device manufacturer's name.</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canCHANNELDATA_DEVDESCR_UNICODE">
            <summary>Buffer points to a string with the product name of the device.
            Note. Not implemented in linux.</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canCHANNELDATA_DEVDESCR_ASCII">
            <summary>Buffer points to a string with the product name of the device.</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canCHANNELDATA_DRIVER_NAME">
            <summary>Buffer points to a string with the name of the device driver (e.g. "kcanl").</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canCHANNELDATA_CHANNEL_QUALITY">
             <summary>Buffer points to a 32-bit unsigned integer that receives the quality of the channel,
             where the quality is measured in percent of optimal quality.
             For WLAN, -90 dBm and -35 dBm are considered 0% and 100%, respectively.
             The quality is 100% for any directly connected channel(USB, PCI etc.).
            </summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canCHANNELDATA_ROUNDTRIP_TIME">
            <summary>Buffer point to a 32-bit unsigned integer that receives the roundtrip time which is
            measured in milliseconds.</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canCHANNELDATA_BUS_TYPE">
            <summary>Buffer points to a 32-bit unsigned integer that receives the kvBUSTYPE_GROUP_xxx bus type.</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canCHANNELDATA_DEVNAME_ASCII">
            <summary>Buffer points to a string with the current device name.</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canCHANNELDATA_TIME_SINCE_LAST_SEEN">
            <summary>Buffer points to a 32-bit unsigned integer that contains the time in milliseconds since
            the last communication occurred.
            For WLAN devices, this is the time since the last keep-alive message. </summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canCHANNELDATA_REMOTE_OPERATIONAL_MODE">
            <summary>Buffer points to a 32-bit unsigned integer that receives the current WLAN operational
            mode of the remote capable device; canCHANNEL_OPMODE_xxx.</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canCHANNELDATA_REMOTE_PROFILE_NAME">
            <summary>Buffer points to a string with the remote profile name of the device.</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canCHANNELDATA_REMOTE_HOST_NAME">
            <summary>Buffer points to a string with the remote host name of the device.</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canCHANNELDATA_REMOTE_MAC">
            <summary>Buffer points to a string with the mac address of the device.</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canCHANNELDATA_MAX_BITRATE">
            <summary>Buffer points to a 32-bit unsigned integer which receives maximum bitrate of the device.
            Zero value means no limit on bitrate.</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canCHANNELDATA_CHANNEL_CAP_MASK">
            <summary>Buffer points to a 32-bit unsigned integer that receives the capabilities mask of the CAN
            channel. This mask specifies which capabilities the device is guaranteed to support/not
            support at the moment, see canCHANNEL_CAP_xxx for info about flags.</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canCHANNELDATA_IS_REMOTE">
            <summary>Buffer points to a 32-bit unsigned integer that is 1 if the channel(device) is currently
            connected as a remote device. 0 if it is not currently a remote device.</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canCHANNELDATA_REMOTE_TYPE">
            <summary>Buffer points to a 32-bit unsigned integer that returns the type of remote connection.
            See kvREMOTE_TYPExxx for returned values.</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canCHANNELDATA_LOGGER_TYPE">
            <summary>Buffer points to a 32-bit unsigned integer that returns the logger type of the device.
            See kvLOGGER_TYPE_xxx for returned values.</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canCHANNELDATA_HW_STATUS">
            <summary>Buffer points to a <see cref="T:Kvaser.CanLib.Canlib.canChannelDataHwStatus"/> with the hardware status codes for the device
            Note. This is only intended for internal use.</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canCHANNELDATA_FEATURE_EAN">
            <summary>Buffer is an unsigned int64 containing the unsigned int32 values, feature eanLo and feature eanHi of the device.
            Note. This is only intended for internal use.</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canCHANNELDATA_BUS_PARAM_LIMITS">
            <summary>This define is used in <see cref="M:Kvaser.CanLib.Canlib.canGetChannelData(System.Int32,System.Int32,System.Object@)"/>, buffer mentioned below refers to this functions argument.
            buffer is <see cref="T:Kvaser.CanLib.Canlib.kvBusParamLimits"/></summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canCHANNELDATA_CLOCK_INFO">
            <summary>This define is used in <see cref="M:Kvaser.CanLib.Canlib.canGetChannelData(System.Int32,System.Int32,System.Object@)"/>, buffer mentioned below refers to this functions argument.
            buffer is <see cref="T:Kvaser.CanLib.Canlib.kvClockInfo"/></summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canCHANNELDATA_CHANNEL_CAP_EX">
             <summary>Buffer points to an array of two 64-bit unsigned integers that receives the capabilities value and capabilities mask of the CAN controller.
             The mask specifies which capabilities the corresponding device is guaranteed to support/not support at the moment.
             Contents depending on index:<para>&#160;</para>
            0: 0<para>value</para>
            1: 0<para>mask</para>
             Value and mask is a combination of the canCHANNEL_CAP_EX_xxx flags.</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canCHANNELDATA_CUST_CHANNEL_NAME">
            <summary>Buffer is a string with channel name.
            If no channel name is set, canERR_NOT_IMPLEMENTED will be returned, regardless of channel name is supported in the device or not.
            </summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canCHANNEL_IS_EXCLUSIVE">
            <summary>Used with canCHANNELDATA_CHANNEL_FLAGS, indicates that the channel is opened exclusively.</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canCHANNEL_IS_OPEN">
            <summary>Used with canCHANNELDATA_CHANNEL_FLAGS, indicates that the channel is active
            (either opened in LIN mode or on-bus in CAN mode.)</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canCHANNEL_IS_CANFD">
            <summary>Used with canCHANNELDATA_CHANNEL_FLAGS, indicates that the channel has been opened
            as CAN FD.</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canCHANNEL_IS_LIN">
             <summary>Reserved for when needed.</summary>
            public const int canCHANNEL_IS_CANFD_NON_ISO = 0x0008;
             <summary>canCHANNELDATA_CHANNEL_FLAGS, indicates that the channel has been opened as LIN.</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canCHANNEL_IS_LIN_MASTER">
            <summary>canCHANNELDATA_CHANNEL_FLAGS, indicates that the channel has been opened as a LIN master.</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canCHANNEL_IS_LIN_SLAVE">
            <summary>canCHANNELDATA_CHANNEL_FLAGS, indicates that the channel has been opened as a LIN slave.</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canDRIVER_OFF">
            <summary>The driver is turned off. Not implemented in all types of hardware.</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canDRIVER_SILENT">
            <summary>Sets the CAN controller in Silent Mode; that is, it doesn't send anything, not even ACK bits, on the bus. Reception works as usual.
            Note: The values 2,3,5,6,7 are reserved values for compatibility reasons.
            </summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canDRIVER_NORMAL">
            <summary>The "normal" driver type (push-pull). This is the default.</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canFILTER_NULL_MASK">
            <summary>Sets the code for standard (11-bit) identifiers.</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canFILTER_ACCEPT">
            <summary>Sets the code for standard (11-bit) identifiers.</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canFILTER_REJECT">
            <summary>Sets the code for standard (11-bit) identifiers.</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canFILTER_SET_CODE_STD">
            <summary>Sets the code for standard (11-bit) identifiers.</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canFILTER_SET_MASK_STD">
            <summary>Sets the code for standard (11-bit) identifiers.</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canFILTER_SET_CODE_EXT">
            <summary>Sets the mask for standard (11-bit) identifiers.</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canFILTER_SET_MASK_EXT">
            <summary>Sets the mask for extended (29-bit) identifiers.</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canHWTYPE_NONE">
            <summary>Unknown or undefined</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canHWTYPE_VIRTUAL">
            <summary>The virtual CAN bus</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canHWTYPE_LAPCAN">
            <summary>LAPcan Family</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canHWTYPE_CANPARI">
            <summary>CANpari (obsolete).</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canHWTYPE_PCCAN">
            <summary>PCcan Family</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canHWTYPE_PCICAN">
            <summary>PCIcan Family</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canHWTYPE_USBCAN">
            <summary>USBcan (obsolete).</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canHWTYPE_PCICAN_II">
            <summary>PCIcan II family</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canHWTYPE_USBCAN_II">
            <summary>USBcan II, USBcan Rugged, Kvaser Memorator</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canHWTYPE_SIMULATED">
            <summary>Simulated CAN bus for Kvaser Creator (obsolete).</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canHWTYPE_ACQUISITOR">
            <summary>Kvaser Acquisitor (obsolete).</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canHWTYPE_LEAF">
            <summary>Kvaser Leaf Family</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canHWTYPE_PC104_PLUS">
            <summary>Kvaser PC104+</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canHWTYPE_PCICANX_II">
            <summary>Kvaser PCIcanx II</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canHWTYPE_MEMORATOR_II">
            <summary>Kvaser Memorator Professional family</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canHWTYPE_MEMORATOR_PRO">
            <summary>Kvaser Memorator Professional family</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canHWTYPE_USBCAN_PRO">
            <summary>Kvaser USBcan Professional</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canHWTYPE_IRIS">
            <summary>Obsolete name, use canHWTYPE_BLACKBIRD instead</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canHWTYPE_BLACKBIRD">
            <summary>Kvaser BlackBird</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canHWTYPE_MEMORATOR_LIGHT">
            <summary>Kvaser Memorator Light</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canHWTYPE_MINIHYDRA">
            <summary>Obsolete name, use canHWTYPE_EAGLE instead</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canHWTYPE_EAGLE">
            <summary>Kvaser Eagle family</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canHWTYPE_BAGEL">
            <summary>Obsolete name, use canHWTYPE_BLACKBIRD_V2 instead</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canHWTYPE_BLACKBIRD_V2">
            <summary>Kvaser BlackBird v2</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canHWTYPE_MINIPCIE">
            <summary>Kvaser Mini PCI Express</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canHWTYPE_USBCAN_KLINE">
            <summary>USBcan Pro HS/K-Line</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canHWTYPE_ETHERCAN">
            <summary>Kvaser Ethercan</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canHWTYPE_USBCAN_LIGHT">
            <summary>Kvaser USBcan Light</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canHWTYPE_USBCAN_PRO2">
            <summary>Kvaser USBcan Pro 5xHS and variants</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canHWTYPE_PCIE_V2">
            <summary>Kvaser PCIEcan 4xHS and variants</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canHWTYPE_MEMORATOR_PRO2">
            <summary>Kvaser Memorator Pro 5xHS and variants</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canHWTYPE_LEAF2">
            <summary>Kvaser Leaf Pro HS v2 and variants</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canHWTYPE_MEMORATOR_V2">
            <summary>Kvaser Memorator (2nd generation)</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canHWTYPE_CANLINHYBRID">
            <summary>Kvaser Hybrid CAN/LIN</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canHWTYPE_DINRAIL">
            <summary>Kvaser DIN Rail SE400S and variants</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canCHANNEL_CAP_EXTENDED_CAN">
            <summary>Can use extended identifiers</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canCHANNEL_CAP_BUS_STATISTICS">
            <summary>Can report busload etc</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canCHANNEL_CAP_ERROR_COUNTERS">
            <summary>Can return error counters</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canCHANNEL_CAP_RESERVED_2">
            <summary>Obsolete, only used by LAPcan driver</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canCHANNEL_CAP_GENERATE_ERROR">
            <summary>Can send error frames</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canCHANNEL_CAP_GENERATE_OVERLOAD">
            <summary>Can send CAN overload frame</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canCHANNEL_CAP_TXREQUEST">
            <summary>Can report when a CAN messsage transmission is initiated</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canCHANNEL_CAP_TXACKNOWLEDGE">
            <summary>Can report when a CAN messages has been transmitted</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canCHANNEL_CAP_VIRTUAL">
            <summary>Virtual CAN channel</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canCHANNEL_CAP_SIMULATED">
            <summary>Simulated CAN channel</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canCHANNEL_CAP_RESERVED_1">
            <summary>Obsolete, use canCHANNEL_CAP_REMOTE_ACCESS or \ref canGetChannelData() instead.</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canCHANNEL_CAP_CAN_FD">
            <summary>CAN-FD ISO compliant channel</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canCHANNEL_CAP_CAN_FD_NONISO">
            <summary>CAN-FD NON-ISO compliant channel</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canCHANNEL_CAP_SILENT_MODE">
            <summary>Channel supports Silent mode</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canCHANNEL_CAP_SINGLE_SHOT">
            <summary>Channel supports Single Shot messages</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canCHANNEL_CAP_LOGGER">
            <summary>Channel has logger capabilities.</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canCHANNEL_CAP_REMOTE_ACCESS">
            <summary>Channel has remote capabilities.</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canCHANNEL_CAP_SCRIPT">
            <summary>Channel has script capabilities.</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canCHANNEL_CAP_LIN_HYBRID">
            <summary>Channel has LIN capabilities.</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canCHANNEL_CAP_IO_API">
            <summary>Channel has IO API capabilities.</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canCHANNEL_CAP_DIAGNOSTICS">
            <summary>Channel has diagnostic capabilities.</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canCHANNEL_CAP_EX_BUSPARAMS_TQ">
            <summary>Channel has Busparams TQ capabilities.</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canCHANNEL_OPMODE_NONE">
            <summary> WLAN Operational mode</summary>
            <summary>Not applicable, or unknown </summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canCHANNEL_OPMODE_INFRASTRUCTURE">
            <summary>Infrastructure mode </summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canCHANNEL_OPMODE_RESERVED">
            <summary>Reserved value, do not use </summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canCHANNEL_OPMODE_ADHOC">
            <summary>Adhoc mode </summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canDRIVER_CAP_HIGHSPEED">
            <summary> Driver (transceiver) capabilities</summary>
            <summary>Used with <see cref="F:Kvaser.CanLib.Canlib.canCHANNELDATA_TRANS_CAP"/> </summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canEVENT_RX">
            <summary> Notification codes; appears in the notification <see cref="F:Kvaser.CanLib.Canlib.WM__CANLIB"/> message.</summary>
            <summary>when the queue of received CAN messages goes from empty to non-empty </summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canEVENT_TX">
            <summary>when a CAN message has been transmitted </summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canEVENT_ERROR">
            <summary>when a CAN bus error is reported by the CAN controller </summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canEVENT_STATUS">
            <summary>when the CAN controller changes state </summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canEVENT_ENVVAR">
            <summary>An envvar changed. </summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canEVENT_BUSONOFF">
            <summary>Bus on/off status changed. </summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canEVENT_REMOVED">
            <summary>Device removed. </summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canOPEN_EXCLUSIVE">
            Flags that can be combined in a call to <see cref="M:Kvaser.CanLib.Canlib.canOpenChannel(System.Int32,System.Int32)"/>.
            <summary>Don't allow sharing of this CANlib channel between applications.</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canOPEN_REQUIRE_EXTENDED">
            <summary>This flag causes two things to happen:
            The call will fail if the specified circuit doesn't allow extended CAN  (CAN 2.0B).
            or
            If no frame-type flag is specified in a call to <see cref="M:Kvaser.CanLib.Canlib.canWrite(System.Int32,System.Int32,System.Byte[],System.Int32,System.Int32)"/>, it is assumed
            that extended CAN should be used.</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canOPEN_ACCEPT_VIRTUAL">
            <summary>Allow opening of virtual channels as well as physical channels.</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canOPEN_OVERRIDE_EXCLUSIVE">
            <summary>Open the channel even if it is opened for exclusive access already. Warning! Use this flag with caution.</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canOPEN_REQUIRE_INIT_ACCESS">
            <summary>Fail the call if the channel cannot be opened with init access.
            Init access means that the CAN handle can set bit rate and CAN driver mode. At most one CAN handle may have init access to any given channel.<para>&#160;</para>
            If you try to set the bit rate or CAN driver mode for a handle to which you don't have init access, the call will silently fail (i.e. <see cref="F:Kvaser.CanLib.Canlib.canStatus.canOK"/> is
            returned although the call had no effect), unless you enable "access error reporting" by calling <see cref="M:Kvaser.CanLib.Canlib.canIoCtl(System.Int32,System.Int32,System.Object@)"/> using <see cref="F:Kvaser.CanLib.Canlib.canIOCTL_SET_REPORT_ACCESS_ERRORS"/>.
            Access error reporting is by default off. Init access is the default.
            </summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canOPEN_NO_INIT_ACCESS">
            <summary>Don't open the handle with init access.
            A handle opened without init access will still set default bitrate when going on bus, if no other handle has opened the channel with init access at the time of the buson.
            </summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canOPEN_ACCEPT_LARGE_DLC">
            <summary>The channel will accept messages with DLC (Data Length Code) greater than 8.
             If this flag is not used, a message with DLC > 8 will always be reported or transmitted as a message with DLC = 8.
             If the <see cref="F:Kvaser.CanLib.Canlib.canOPEN_ACCEPT_LARGE_DLC"/> flag is used, the message will be sent and/or received with the true DLC, which can be at most 15.
             Note. The length of the message is always at most 8.</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canOPEN_CAN_FD">
            <summary>The channel will use the CAN FD protocol, ISO compliant.</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canOPEN_CAN_FD_NONISO">
            <summary>The channel will use the CAN FD NON-ISO protocol. Use this if you want to configure the can controller to be able to communicate with a can controller
            designed prior to the release of the CAN FD ISO specification.
            Non ISO mode implies:
            <para>&#160;</para>
            The stuff bit counter will not be included in the frame format.<para>&#160;</para>
            Initial value for CRC17 and CRC21 will be zero.<para>&#160;</para>
            This also means that messages with canFDMSG_xxx flags can now be used.</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canMSG_MASK">
            <summary>Used to mask the non-info bits.</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canMSG_RTR">
            <summary>Message is a remote request.</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canMSG_STD">
            <summary>Message has a standard (11-bit) identifier.</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canMSG_EXT">
            <summary>Message has an extended(29-bit) identifier.</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canMSG_WAKEUP">
            <summary>Message is a WAKEUP message(SWC hardware.)</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canMSG_NERR">
            <summary>NERR was active during the message(TJA1054 hardware)</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canMSG_ERROR_FRAME">
            <summary>Message represents an error frame.</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canMSG_TXACK">
            <summary>Message is a TX ACK(msg has really been sent)</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canMSG_TXRQ">
            <summary>Message is a TX REQUEST(msg was transfered to the chip)</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canMSG_DELAY_MSG">
            <summary>Message is NOT sent on the bus. The transmission of messages are delayed. The dlc specifies
            the delay in milliseconds (1..1000).</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canMSG_SINGLE_SHOT">
            <summary>Message is Single Shot, try to send once, no retransmission. This flag can only be used with
            transmitted messages.</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canMSG_TXNACK">
            <summary>Message is a failed Single Shot, message was not sent. This flag is only used with received messages.</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canMSG_ABL">
            <summary>Only together with canMSG_TXNACK, Single shot message was not sent because arbitration was lost.
            This flag is only used with received messages.</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canMSGERR_MASK">
            <summary>Used to mask the non-error bits</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canMSGERR_HW_OVERRUN">
            <summary>HW buffer overrun</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canMSGERR_SW_OVERRUN">
            <summary>SW buffer overrun</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canMSGERR_STUFF">
            <summary>Stuff error</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canMSGERR_FORM">
            <summary>Form error</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canMSGERR_CRC">
            <summary>CRC error</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canMSGERR_BIT0">
            <summary>Sent dom, read rec</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canMSGERR_BIT1">
            <summary>Sent rec, read dom</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canMSGERR_OVERRUN">
            <summary>Any overrun condition. \sa \ref section_user_guide_send_recv_overruns</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canMSGERR_BIT">
            <summary>Any bit error.</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canMSGERR_BUSERR">
            <summary>Any RX error</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canFDMSG_MASK">
            <summary>Bit mask for canFDMSG_XXX bits</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canFDMSG_FDF">
            <summary>Message is an FD message (CAN FD)</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canFDMSG_BRS">
            <summary>Message is sent/received with bit rate switch (CAN FD)</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canFDMSG_ESI">
            <summary>Sender of the message is in error passive mode (CAN FD)</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canSTAT_ERROR_PASSIVE">
            <summary>The circuit is error passive.</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canSTAT_BUS_OFF">
            <summary>The circuit is Off Bus.</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canSTAT_ERROR_WARNING">
            <summary> At least one error counter > 96.</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canSTAT_ERROR_ACTIVE">
            <summary>The circuit is error active.</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canSTAT_TX_PENDING">
            <summary>There are messages pending transmission.</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canSTAT_RX_PENDING">
            <summary>There are messages in the receive buffer.</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canSTAT_RESERVED_1">
            <summary>The circuit is error passive.</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canSTAT_TXERR">
            <summary>There has been at least one TX error.</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canSTAT_RXERR">
            <summary>There has been at least one RX error of some sort.</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canSTAT_HW_OVERRUN">
            <summary>There has been at least one HW buffer overflow.</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canSTAT_SW_OVERRUN">
            <summary>There has been at least one SW buffer overflow.</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canSTAT_OVERRUN">
            <summary>For convenience.</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canIOCTL_PREFER_EXT">
            <summary>Prefer extended identifiers (Value is ignored).</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canIOCTL_PREFER_STD">
            <summary>Prefer standard identifiers (Value is ignored).</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canIOCTL_CLEAR_ERROR_COUNTERS">
            <summary>Clear the Can Error Counter (Value is ignored).</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canIOCTL_SET_TIMER_SCALE">
            <summary>Set Timer Scale (default value is 1000 us. Input value is a uint32 in us) .</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canIOCTL_SET_TXACK">
            <summary>Enabling transmit Acknowledges on a channel (Input value is a uint32).</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canIOCTL_GET_RX_BUFFER_LEVEL">
            <summary>Get the current RX buffer level (Return value is a uint32).</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canIOCTL_GET_TX_BUFFER_LEVEL">
            <summary>Get the current TX buffer level (Return value is a uint32).</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canIOCTL_FLUSH_RX_BUFFER">
            <summary>Discard the current contents of the RX queue (Value is ignored).</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canIOCTL_FLUSH_TX_BUFFER">
            <summary>Discard the current contents of the TX queue (Value is ignored).</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canIOCTL_GET_TIMER_SCALE">
            <summary>Get the Current timer scale (Value is a uint32 in us).</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canIOCTL_SET_TXRQ">
            <summary>Turns transmit requests on or off.(Valid input values are 0 and 1 (uint32))</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canIOCTL_GET_EVENTHANDLE">
            <summary>Buf points at a HANDLE which receives a Windows Event handle which can be passed to the
            Win32 API WaitForSingleObject.</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canIOCTL_SET_BYPASS_MODE">
            <summary>Not yet implemented.</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canIOCTL_SET_WAKEUP">
            <summary>This is only intended for internal use.</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canIOCTL_GET_DRIVERHANDLE">
            <summary>Buf points to a HANDLE which receives the Windows handle related to the CANlib handle.</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canIOCTL_MAP_RXQUEUE">
            <summary>This is only intended for internal use.</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canIOCTL_GET_WAKEUP">
            <summary>This is only intended for internal use.</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canIOCTL_SET_REPORT_ACCESS_ERRORS">
            <summary>Buf points to a unsigned char which contains, 0 to turn access error reporting off, and
            1 to turn access error reporting on.</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canIOCTL_GET_REPORT_ACCESS_ERRORS">
            <summary>Returns an Int32 the current setting of the access error reporting (0 or 1.)</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canIOCTL_CONNECT_TO_VIRTUAL_BUS">
            <summary>Connects the handle to the virtual bus number (0..31) which the buf points to. Argument is of type unsigned int</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canIOCTL_DISCONNECT_FROM_VIRTUAL_BUS">
            <summary>Disconnects the handle from the virtual bus number (0..31) which the buf points to. Argument is of type unsigned int</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canIOCTL_SET_USER_IOPORT">
            <summary>Buf points to a canUserIoPortData struct that contains a port number and a port value to set.
            This is used by special hardware only.</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canIOCTL_GET_USER_IOPORT">
            <summary>Buf points to a canUserIoPortData struct that contains a port number. After the call, the
            struct will contain the current value of the I/O port. This is used by special hardware only.</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canIOCTL_SET_BUFFER_WRAPAROUND_MODE">
            <summary>This is only intended for internal use.</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canIOCTL_SET_RX_QUEUE_SIZE">
            <summary>Use this function code to set the size of the receive buffer for a specific handle.
            Value is a uint32 which contains the new size (number of messages) of the receive buffer.</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canIOCTL_SET_USB_THROTTLE">
            <summary>This is only intended for internal use.</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canIOCTL_GET_USB_THROTTLE">
            <summary>This is only intended for internal use.</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canIOCTL_SET_BUSON_TIME_AUTO_RESET">
            <summary>This function enables or disables automatic time reset on bus on. Argument is of type Int32 with value enable or disable (1 or 0).  </summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canIOCTL_GET_TXACK">
            <summary>Returns the state of the Transmit Acknowledge as a uint32</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canIOCTL_SET_LOCAL_TXECHO">
            <summary>Buf points to an unsigned byte. If the value is zero, the local transmit echo is turned
            off for the handle. Otherwise, local transmit echo is turned on.</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canIOCTL_SET_ERROR_FRAMES_REPORTING">
            <summary>This function turns error frame reporting on or off. Argument is of type Int32 with value on or off (1 or 0). </summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canIOCTL_GET_CHANNEL_QUALITY">
            <summary>Value is a uint32 that receives the quality of the channel, where the quality is measured
            in percent of optimal quality.</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canIOCTL_GET_ROUNDTRIP_TIME">
            <summary>Returns the round trip time to a device. value is a uint32 that contains the roundtrip
            time measured in milliseconds.</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canIOCTL_GET_BUS_TYPE">
            <summary>Value is a uint32 that contains the kvBUSTYPE_GROUP_xxx bus type.</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canIOCTL_GET_DEVNAME_ASCII">
            <summary>
            Value is a string with the current device name.
            <remarks>Not supported on Linux.</remarks>>
            </summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canIOCTL_GET_TIME_SINCE_LAST_SEEN">
            <summary>Value is a uint32 that contains the time in milliseconds since the last communication occurred.</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canIOCTL_TX_INTERVAL">
            <summary>Value a uint32 that contains the number of microseconds the minimum CAN message transmit
            interval should be set to, or 0xffffffff to fetch the current setting. The minimum interval can not be set to more than one second.</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canIOCTL_SET_BRLIMIT">
            <summary>Value is uint32 that contains a user defined bitrate. A value of 0 means that the device
            should use its own default bitrate limit.</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canIOCTL_SET_THROTTLE_SCALED">
            <summary>Set the responsitivity of some devices. Value is a uint32 that should contain a value between 0 and 100.</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canIOCTL_GET_THROTTLE_SCALED">
            <summary>Set the responsitivity of some devices. Value is a uint32 that should contain a value between 0 and 100.</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canIOCTL_RESET_OVERRUN_COUNT">
            <summary>Reset overrun count and flags, buf argument is ignored</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canIOCTL_LIN_MODE">
            <summary>Set the current LIN access mode returned in canCHANNELDATA_CHANNEL_FLAGS. Note. Only fInternal Use</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canNOTIFY_NONE">
            <summary>Used in <see cref="M:Kvaser.CanLib.Canlib.kvSetNotifyCallback(System.Int32,Kvaser.CanLib.Canlib.kvCallbackDelegate,System.IntPtr,System.Int32)"/> as notification flags. Turn notifications off. .</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canNOTIFY_RX">
            <summary>Used in <see cref="M:Kvaser.CanLib.Canlib.kvSetNotifyCallback(System.Int32,Kvaser.CanLib.Canlib.kvCallbackDelegate,System.IntPtr,System.Int32)"/> as notification flags. CAN message reception notification.</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canNOTIFY_TX">
            <summary>Used in <see cref="M:Kvaser.CanLib.Canlib.kvSetNotifyCallback(System.Int32,Kvaser.CanLib.Canlib.kvCallbackDelegate,System.IntPtr,System.Int32)"/> as notification flags. CAN message transmission notification.</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canNOTIFY_ERROR">
            <summary>Used in <see cref="M:Kvaser.CanLib.Canlib.kvSetNotifyCallback(System.Int32,Kvaser.CanLib.Canlib.kvCallbackDelegate,System.IntPtr,System.Int32)"/> as notification flags. CAN bus error notification.</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canNOTIFY_STATUS">
            <summary>Used in <see cref="M:Kvaser.CanLib.Canlib.kvSetNotifyCallback(System.Int32,Kvaser.CanLib.Canlib.kvCallbackDelegate,System.IntPtr,System.Int32)"/> as notification flags. CAN chip status change.</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canNOTIFY_ENVVAR">
            <summary>Used in <see cref="M:Kvaser.CanLib.Canlib.kvSetNotifyCallback(System.Int32,Kvaser.CanLib.Canlib.kvCallbackDelegate,System.IntPtr,System.Int32)"/> as notification flags.An environment variable was changed by a script. Note that you will not be notified when an environment variable is updated from the Canlib API.</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canNOTIFY_BUSONOFF">
            <summary>Used in <see cref="M:Kvaser.CanLib.Canlib.kvSetNotifyCallback(System.Int32,Kvaser.CanLib.Canlib.kvCallbackDelegate,System.IntPtr,System.Int32)"/> as notification flags. Notify on bus on/off status changed.</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canNOTIFY_REMOVED">
            <summary>Used in <see cref="M:Kvaser.CanLib.Canlib.kvSetNotifyCallback(System.Int32,Kvaser.CanLib.Canlib.kvCallbackDelegate,System.IntPtr,System.Int32)"/> as notification flags. Notify on device removed. </summary>
        </member>
        <member name="T:Kvaser.CanLib.Canlib.canObjBufType">
            <summary> These defines are used when allocating object buffers using <see cref="M:Kvaser.CanLib.Canlib.canObjBufAllocate(System.Int32,Kvaser.CanLib.Canlib.canObjBufType)"/>. </summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canObjBufType.AUTO_RESPONSE">
            <summary>The requested buffer is an auto-response buffer.</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canObjBufType.PERIODIC_TX">
            <summary>The requested buffer is an auto-transmit buffer.</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canOBJBUF_AUTO_RESPONSE_RTR_ONLY">
            <summary>This constant is used in <see cref="M:Kvaser.CanLib.Canlib.canObjBufSetFlags(System.Int32,System.Int32,System.Int32)"/>.</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canTRANSCEIVER_LINEMODE_NA">
            <summary>Not Affected/Not available.</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canTRANSCEIVER_LINEMODE_SWC_SLEEP">
            <summary>SWC Sleep Mode.</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canTRANSCEIVER_LINEMODE_SWC_NORMAL">
            <summary>SWC Normal Mode.</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canTRANSCEIVER_LINEMODE_SWC_FAST">
            <summary>SWC High-Speed Mode.</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canTRANSCEIVER_LINEMODE_SWC_WAKEUP">
            <summary>SWC Wakeup Mode.</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canTRANSCEIVER_LINEMODE_SLEEP">
            <summary>Sleep mode for those supporting it.</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canTRANSCEIVER_LINEMODE_NORMAL">
            <summary>Normal mode (the inverse of sleep mode) for those supporting it.</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canTRANSCEIVER_LINEMODE_STDBY">
            <summary>Standby for those who support it.</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canTRANSCEIVER_LINEMODE_TT_CAN_H">
            <summary>Truck and Trailer: operating mode single wire using CAN high.</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canTRANSCEIVER_LINEMODE_TT_CAN_L">
            <summary>Truck and Trailer: operating mode single wire using CAN low.</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canTRANSCEIVER_LINEMODE_OEM1">
            <summary>Reserved for OEM apps.</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canTRANSCEIVER_LINEMODE_OEM2">
            <summary>Reserved for OEM apps.</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canTRANSCEIVER_LINEMODE_OEM3">
            <summary>Reserved for OEM apps.</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canTRANSCEIVER_LINEMODE_OEM4">
            <summary>Reserved for OEM apps.</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canTRANSCEIVER_RESNET_NA">
            <summary></summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canTRANSCEIVER_RESNET_MASTER">
            <summary></summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canTRANSCEIVER_RESNET_MASTER_STBY">
            <summary></summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canTRANSCEIVER_RESNET_SLAVE">
            <summary></summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canTRANSCEIVER_TYPE_UNKNOWN">
            <summary>Transceiver (logical) types.</summary>
             <summary>Unknown or undefined.</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canTRANSCEIVER_TYPE_251">
            <summary>82c251 </summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canTRANSCEIVER_TYPE_252">
            <summary>82c252, TJA1053, TJA1054 </summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canTRANSCEIVER_TYPE_DNOPTO">
            <summary>Optoisolated 82C251. </summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canTRANSCEIVER_TYPE_W210">
            <summary>Unknown or undefined. </summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canTRANSCEIVER_TYPE_SWC_PROTO">
            <summary>AU5790 prototype. </summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canTRANSCEIVER_TYPE_SWC">
            <summary>AU5790. </summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canTRANSCEIVER_TYPE_EVA">
            <summary>Unknown or undefined.</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canTRANSCEIVER_TYPE_FIBER">
            <summary>82c251 with fibre extension </summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canTRANSCEIVER_TYPE_K251">
            <summary>K-line + 82c251. </summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canTRANSCEIVER_TYPE_K">
            <summary>K-line, without CAN. </summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canTRANSCEIVER_TYPE_1054_OPTO">
            <summary>TJA1054 with optical isolation. </summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canTRANSCEIVER_TYPE_SWC_OPTO">
            <summary>AU5790 with optical isolation. </summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canTRANSCEIVER_TYPE_TT">
            <summary>B10011S Truck-And-Trailer. </summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canTRANSCEIVER_TYPE_1050">
            <summary>TJA1050. </summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canTRANSCEIVER_TYPE_1050_OPTO">
            <summary>TJA1050 with optical isolation. </summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canTRANSCEIVER_TYPE_1041">
            <summary>TJA1041. </summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canTRANSCEIVER_TYPE_1041_OPTO">
            <summary>TJA1041 with optical isolation. </summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canTRANSCEIVER_TYPE_RS485">
            <summary>RS485 (i.e. J1708) </summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canTRANSCEIVER_TYPE_LIN">
            <summary>LIN. </summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canTRANSCEIVER_TYPE_KONE">
            <summary>KONE. </summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canTRANSCEIVER_TYPE_CANFD">
            <summary>CAN-FD. </summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canTRANSCEIVER_TYPE_CANFD_LIN">
            <summary>HYBRID CAN-FD/LIN. </summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canTRANSCEIVER_TYPE_LINX_LIN">
            <summary>Unknown or undefined. </summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canTRANSCEIVER_TYPE_LINX_J1708">
            <summary>Unknown or undefined. </summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canTRANSCEIVER_TYPE_LINX_K">
            <summary>Unknown or undefined. </summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canTRANSCEIVER_TYPE_LINX_SWC">
            <summary>Unknown or undefined. </summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canTRANSCEIVER_TYPE_LINX_LS">
            <summary>Unknown or undefined. </summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canTXEDATA_FILE_VERSION">
            <summary>These defines are used in <see cref="M:Kvaser.CanLib.Canlib.kvScriptTxeGetData(System.String,System.Int32,System.Object@)"/>.
            buffer points to an array of 3 32-bit unsigned integers which receives the three part version number of the compiled script file(.txe) file format
            </summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canTXEDATA_COMPILER_VERSION">
            <summary>These defines are used in <see cref="M:Kvaser.CanLib.Canlib.kvScriptTxeGetData(System.String,System.Int32,System.Object@)"/>.
             buffer points to an array of 3 32-bit unsigned integers which receives the three part version number of the compiler used to create the compiled script file(.txe).
            </summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canTXEDATA_DATE">
            <summary>These defines are used in <see cref="M:Kvaser.CanLib.Canlib.kvScriptTxeGetData(System.String,System.Int32,System.Object@)"/>.
            buffer points to an array of 6 32-bit unsigned integers which receive the compilation date in Coordinated Universal Time(UTC) of the compiled script file(.txe).
            </summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canTXEDATA_DESCRIPTION">
            <summary>These defines are used in <see cref="M:Kvaser.CanLib.Canlib.kvScriptTxeGetData(System.String,System.Int32,System.Object@)"/>.
            buffer points to an area which receives a zero-terminated string with a description of the compiled script file(.txe).
            </summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canTXEDATA_SOURCE">
            <summary>These defines are used in <see cref="M:Kvaser.CanLib.Canlib.kvScriptTxeGetData(System.String,System.Int32,System.Object@)"/>.
             buffer points to an area which receives a list containing the names and content of all source files which were used to generate the compiled script file(.txe).
            </summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canTXEDATA_SIZE_OF_CODE">
            <summary>These defines are used in <see cref="M:Kvaser.CanLib.Canlib.kvScriptTxeGetData(System.String,System.Int32,System.Object@)"/>.
             buffer points to a single unsigned integer which receives the size of the compiled code of the compiled script file(.txe).
            </summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canTXEDATA_IS_ENCRYPTED">
            <summary>These defines are used in <see cref="M:Kvaser.CanLib.Canlib.kvScriptTxeGetData(System.String,System.Int32,System.Object@)"/>.
            buffer points to a single unsigned integer which will receive a non-zero value if the compiled script file (.txe) contents is encrypted.
            </summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canVERSION_DONT_ACCEPT_LATER">
            <summary></summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canVERSION_DONT_ACCEPT_BETAS">
            <summary></summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canVERSION_CANLIB32_VERSION">
            <summary>Version number of the canlib32.dll file coded as an unsigned 16-bit word.</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canVERSION_CANLIB32_PRODVER">
            <summary>Product version number of CANlib coded as an unsigned 16-bit word.</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canVERSION_CANLIB32_PRODVER32">
            <summary>Product version number of canlib32.dll coded as an unsigned 32-bit word.</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canVERSION_CANLIB32_BETA">
            <summary>Returns 1 if the present version is a beta (preview) release, or 0 if it is an official release.</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.kvBUSTYPE_NONE">
            <summary>Unkown bus type.
            Note.  Not inplemented in linux.</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.kvBUSTYPE_PCI">
            <summary>Bus of type PCI.
            Note.  Not inplemented in linux.</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.kvBUSTYPE_PCMCIA">
            <summary>Bus of type PCMCIA.
            Note.  Not inplemented in linux.</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.kvBUSTYPE_USB">
            <summary>Bus of type USB.
            Note.  Not inplemented in linux.</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.kvBUSTYPE_WLAN">
            <summary>Bus of type WLAN.
            Note.  Not inplemented in linux.</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.kvBUSTYPE_PCI_EXPRESS">
            <summary>Bus of type PCI Express.
            Note.  Not inplemented in linux.</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.kvBUSTYPE_ISA">
            <summary>Bus of type ISA.
            Note.  Not inplemented in linux.</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.kvBUSTYPE_VIRTUAL">
            <summary>Bus of type virtual.
            Note.  Not inplemented in linux.</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.kvBUSTYPE_PC104_PLUS">
            <summary>Bus of type PC104+.
            Note.  Not inplemented in linux.</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.kvBUSTYPE_LAN">
            <summary>Bus of type LAN.
            Note.  Not inplemented in linux.</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.kvBUSTYPE_GROUP_VIRTUAL">
            <summary>BusType Virtual.</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.kvBUSTYPE_GROUP_LOCAL">
            <summary>BusType Local.</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.kvBUSTYPE_GROUP_REMOTE">
            <summary>BusType Remote.</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.kvBUSTYPE_GROUP_INTERNAL">
            <summary>BusType Internal.</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.kvDEVICE_MODE_INTERFACE">
            <summary>Used in <see cref="M:Kvaser.CanLib.Canlib.kvDeviceSetMode(System.Int32,System.Int32)"/> and <see cref="M:Kvaser.CanLib.Canlib.kvDeviceGetMode(System.Int32,System.Int32@)"/>. Device is running or should be running in interface mode.</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.kvDEVICE_MODE_LOGGER">
            <summary>Used in <see cref="M:Kvaser.CanLib.Canlib.kvDeviceSetMode(System.Int32,System.Int32)"/> and <see cref="M:Kvaser.CanLib.Canlib.kvDeviceGetMode(System.Int32,System.Int32@)"/>. Device is running or should be running in logger mode.</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.kvENVVAR_TYPE_INT">
            <summary>This define is used in <see cref="M:Kvaser.CanLib.Canlib.kvScriptEnvvarOpen(System.Int32,System.String,System.Int32@,System.Int32@)"/>. It defines the type of the envvar as int.</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.kvENVVAR_TYPE_FLOAT">
            <summary>This define is used in <see cref="M:Kvaser.CanLib.Canlib.kvScriptEnvvarOpen(System.Int32,System.String,System.Int32@,System.Int32@)"/>. It defines the type of the envvar as float.</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.kvENVVAR_TYPE_STRING">
            <summary>This define is used in <see cref="M:Kvaser.CanLib.Canlib.kvScriptEnvvarOpen(System.Int32,System.String,System.Int32@,System.Int32@)"/>. It defines the type of the envvar as string.</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.kvEVENT_TYPE_KEY">
            <summary>This define is used in <see cref="M:Kvaser.CanLib.Canlib.kvScriptEnvvarOpen(System.Int32,System.String,System.Int32@,System.Int32@)"/>. It defines an event of type "key pressed".</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.kvLED_ACTION_ALL_LEDS_ON">
            <summary>This constant is used in <see cref="M:Kvaser.CanLib.Canlib.kvFlashLeds(System.Int32,System.Int32,System.Int32)"/>. Turn all LEDs on.</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.kvLED_ACTION_ALL_LEDS_OFF">
            <summary>This constant is used in <see cref="M:Kvaser.CanLib.Canlib.kvFlashLeds(System.Int32,System.Int32,System.Int32)"/>. Turn all LEDs off.</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.kvLED_ACTION_LED_0_ON">
            <summary>This constant is used in <see cref="M:Kvaser.CanLib.Canlib.kvFlashLeds(System.Int32,System.Int32,System.Int32)"/>. Turn LED 0 on.</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.kvLED_ACTION_LED_0_OFF">
            <summary>This constant is used in <see cref="M:Kvaser.CanLib.Canlib.kvFlashLeds(System.Int32,System.Int32,System.Int32)"/>. Turn LED 0 off.</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.kvLED_ACTION_LED_1_ON">
            <summary>This constant is used in <see cref="M:Kvaser.CanLib.Canlib.kvFlashLeds(System.Int32,System.Int32,System.Int32)"/>. Turn LED 1 on.</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.kvLED_ACTION_LED_1_OFF">
            <summary>This constant is used in <see cref="M:Kvaser.CanLib.Canlib.kvFlashLeds(System.Int32,System.Int32,System.Int32)"/>. Turn LED 1 off.</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.kvLED_ACTION_LED_2_ON">
            <summary>This constant is used in <see cref="M:Kvaser.CanLib.Canlib.kvFlashLeds(System.Int32,System.Int32,System.Int32)"/>. Turn LED 2 on.</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.kvLED_ACTION_LED_2_OFF">
            <summary>This constant is used in <see cref="M:Kvaser.CanLib.Canlib.kvFlashLeds(System.Int32,System.Int32,System.Int32)"/>. Turn LED 2 off.</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.kvLED_ACTION_LED_3_ON">
            <summary>This constant is used in <see cref="M:Kvaser.CanLib.Canlib.kvFlashLeds(System.Int32,System.Int32,System.Int32)"/>. Turn LED 3 on.</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.kvLED_ACTION_LED_3_OFF">
            <summary>This constant is used in <see cref="M:Kvaser.CanLib.Canlib.kvFlashLeds(System.Int32,System.Int32,System.Int32)"/>. Turn LED 3 off.</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.kvLED_ACTION_LED_4_ON">
            <summary>This constant is used in <see cref="M:Kvaser.CanLib.Canlib.kvFlashLeds(System.Int32,System.Int32,System.Int32)"/>. Turn LED 4 on.</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.kvLED_ACTION_LED_4_OFF">
            <summary>This constant is used in <see cref="M:Kvaser.CanLib.Canlib.kvFlashLeds(System.Int32,System.Int32,System.Int32)"/>. Turn LED 4 off.</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.kvLED_ACTION_LED_5_ON">
            <summary>This constant is used in <see cref="M:Kvaser.CanLib.Canlib.kvFlashLeds(System.Int32,System.Int32,System.Int32)"/>. Turn LED 5 on.</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.kvLED_ACTION_LED_5_OFF">
            <summary>This constant is used in <see cref="M:Kvaser.CanLib.Canlib.kvFlashLeds(System.Int32,System.Int32,System.Int32)"/>. Turn LED 5 off.</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.kvLED_ACTION_LED_6_ON">
            <summary>This constant is used in <see cref="M:Kvaser.CanLib.Canlib.kvFlashLeds(System.Int32,System.Int32,System.Int32)"/>. Turn LED 6 on.</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.kvLED_ACTION_LED_6_OFF">
            <summary>This constant is used in <see cref="M:Kvaser.CanLib.Canlib.kvFlashLeds(System.Int32,System.Int32,System.Int32)"/>. Turn LED 6 off.</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.kvLED_ACTION_LED_7_ON">
            <summary>This constant is used in <see cref="M:Kvaser.CanLib.Canlib.kvFlashLeds(System.Int32,System.Int32,System.Int32)"/>. Turn LED 7 on.</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.kvLED_ACTION_LED_7_OFF">
            <summary>This constant is used in <see cref="M:Kvaser.CanLib.Canlib.kvFlashLeds(System.Int32,System.Int32,System.Int32)"/>. Turn LED 7 off.</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.kvLED_ACTION_LED_8_ON">
            <summary>This constant is used in <see cref="M:Kvaser.CanLib.Canlib.kvFlashLeds(System.Int32,System.Int32,System.Int32)"/>. Turn LED 8 on.</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.kvLED_ACTION_LED_8_OFF">
            <summary>This constant is used in <see cref="M:Kvaser.CanLib.Canlib.kvFlashLeds(System.Int32,System.Int32,System.Int32)"/>. Turn LED 8 off.</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.kvLED_ACTION_LED_9_ON">
            <summary>This constant is used in <see cref="M:Kvaser.CanLib.Canlib.kvFlashLeds(System.Int32,System.Int32,System.Int32)"/>. Turn LED 9 on.</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.kvLED_ACTION_LED_9_OFF">
            <summary>This constant is used in <see cref="M:Kvaser.CanLib.Canlib.kvFlashLeds(System.Int32,System.Int32,System.Int32)"/>. Turn LED 9 off.</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.kvLED_ACTION_LED_10_ON">
            <summary>This constant is used in <see cref="M:Kvaser.CanLib.Canlib.kvFlashLeds(System.Int32,System.Int32,System.Int32)"/>. Turn LED 10 on.</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.kvLED_ACTION_LED_10_OFF">
            <summary>This constant is used in <see cref="M:Kvaser.CanLib.Canlib.kvFlashLeds(System.Int32,System.Int32,System.Int32)"/>. Turn LED 10 off.</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.kvLED_ACTION_LED_11_ON">
            <summary>This constant is used in <see cref="M:Kvaser.CanLib.Canlib.kvFlashLeds(System.Int32,System.Int32,System.Int32)"/>. Turn LED 11 on.</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.kvLED_ACTION_LED_11_OFF">
            <summary>This constant is used in <see cref="M:Kvaser.CanLib.Canlib.kvFlashLeds(System.Int32,System.Int32,System.Int32)"/>. Turn LED 11 off.</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.kvSCRIPT_STOP_NORMAL">
            <summary>Script stop modes. Used by <see cref="M:Kvaser.CanLib.Canlib.kvScriptStop(System.Int32,System.Int32,System.Int32)"/>. Stop a running script .</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.kvSCRIPT_STOP_FORCED">
            <summary>Script stop modes. Used by <see cref="M:Kvaser.CanLib.Canlib.kvScriptStop(System.Int32,System.Int32,System.Int32)"/>. Request termination of a hanged script.</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.kvSCRIPT_REQUEST_TEXT_UNSUBSCRIBE">
            <summary>These defines are used in <see cref="M:Kvaser.CanLib.Canlib.kvScriptRequestText(System.Int32,System.Int32,System.Int32)"/> for printf message subscribe/unsubscribe. Cancel subscription of printf messages from script slots.</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.kvSCRIPT_REQUEST_TEXT_SUBSCRIBE">
            <summary>These defines are used in <see cref="M:Kvaser.CanLib.Canlib.kvScriptRequestText(System.Int32,System.Int32,System.Int32)"/> for printf message subscribe/unsubscribe. Cancel subscription of printf messages from script slots.</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.kvSCRIPT_REQUEST_TEXT_ALL_SLOTS">
            <summary>These defines are used in <see cref="M:Kvaser.CanLib.Canlib.kvScriptRequestText(System.Int32,System.Int32,System.Int32)"/> for printf message subscribe/unsubscribe. Cancel subscription of printf messages from script slots.</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.kvSCRIPT_STATUS_LOADED">
            <summary>Script status flag bits. Used by <see cref="M:Kvaser.CanLib.Canlib.kvScriptStatus(System.Int32,System.Int32,System.Int32@)"/>. The slot is loaded with a script.</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.kvSCRIPT_STATUS_RUNNING">
            <summary>Script status flag bits. Used by <see cref="M:Kvaser.CanLib.Canlib.kvScriptStatus(System.Int32,System.Int32,System.Int32@)"/>. The slot is running a script.</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.canINVALID_HANDLE">
            <summary>Indicates an invalid canHandle.</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.WM__CANLIB">
            <summary> Notify message sent to the application window.</summary>
        </member>
        <member name="T:Kvaser.CanLib.Canlib.kvIoModuleDigital">
            <summary>
            This class is used in <see cref="M:Kvaser.CanLib.Canlib.kvIoGetModulePins(System.Int32,System.Int32,System.Object)"/> and <see cref="M:Kvaser.CanLib.Canlib.kvIoSetModulePins(System.Int32,System.Int32,System.Object)"/>.
            It represents a digital add-on module.
            </summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.kvIoModuleDigital.type">
            <summary>The type of the module.</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.kvIoModuleDigital.DO">
            <summary>Digital Out</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.kvIoModuleDigital.DI">
            <summary>Digital In</summary>
        </member>
        <member name="T:Kvaser.CanLib.Canlib.kvIoModuleInternal">
            <summary>
            This class is used in <see cref="M:Kvaser.CanLib.Canlib.kvIoGetModulePins(System.Int32,System.Int32,System.Object)"/> and <see cref="M:Kvaser.CanLib.Canlib.kvIoSetModulePins(System.Int32,System.Int32,System.Object)"/>.
            It represents a digital internal module
            </summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.kvIoModuleInternal.type">
            <summary>The type of the module.</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.kvIoModuleInternal.DIO">
            <summary>Digital Out (Bit 0), Digital In (Bit 1)</summary>
        </member>
        <member name="T:Kvaser.CanLib.Canlib.kvIoModuleRelay">
            <summary>
            This class is used in <see cref="M:Kvaser.CanLib.Canlib.kvIoGetModulePins(System.Int32,System.Int32,System.Object)"/> and <see cref="M:Kvaser.CanLib.Canlib.kvIoSetModulePins(System.Int32,System.Int32,System.Object)"/>.
            It represents a relay add-on module.
            </summary>
            [StructLayout(LayoutKind.Sequential)]
        </member>
        <member name="F:Kvaser.CanLib.Canlib.kvIoModuleRelay.type">
            <summary>The type of the module.</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.kvIoModuleRelay.RO">
            <summary>Relay Out</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.kvIoModuleRelay.DI">
            <summary>Digital In</summary>
        </member>
        <member name="T:Kvaser.CanLib.Canlib.kvIoModuleAnalog">
             <summary>
             This class is used in <see cref="M:Kvaser.CanLib.Canlib.kvIoGetModulePins(System.Int32,System.Int32,System.Object)"/> and <see cref="M:Kvaser.CanLib.Canlib.kvIoSetModulePins(System.Int32,System.Int32,System.Object)"/>.
             It represents an analog add-on module.
            </summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.kvIoModuleAnalog.type">
            <summary>The type of the module.</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.kvIoModuleAnalog.AO1">
            <summary>Analog Out 1</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.kvIoModuleAnalog.AO2">
            <summary>Analog Out 2</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.kvIoModuleAnalog.AO3">
            <summary>Analog Out 3</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.kvIoModuleAnalog.AO4">
            <summary>Analog Out 4</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.kvIoModuleAnalog.AI1">
            <summary>Analog In 1</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.kvIoModuleAnalog.AI2">
            <summary>Analog In 2</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.kvIoModuleAnalog.AI3">
            <summary>Analog In 3</summary>
        </member>
        <member name="F:Kvaser.CanLib.Canlib.kvIoModuleAnalog.AI4">
            <summary>Analog In 4</summary>
        </member>
    </members>
</doc>
